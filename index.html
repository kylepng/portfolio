<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyle | 3D Desktop</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='r' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ff5f5f'/%3E%3Cstop offset='100%25' stop-color='%23cc0000'/%3E%3C/linearGradient%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2355ff55'/%3E%3Cstop offset='100%25' stop-color='%2300aa00'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%235599ff'/%3E%3Cstop offset='100%25' stop-color='%230044cc'/%3E%3C/linearGradient%3E%3ClinearGradient id='y' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffee55'/%3E%3Cstop offset='100%25' stop-color='%23ccaa00'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x='2' y='2' width='13' height='13' rx='2' fill='url(%23r)'/%3E%3Crect x='17' y='2' width='13' height='13' rx='2' fill='url(%23g)'/%3E%3Crect x='2' y='17' width='13' height='13' rx='2' fill='url(%23b)'/%3E%3Crect x='17' y='17' width='13' height='13' rx='2' fill='url(%23y)'/%3E%3C/svg%3E">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Tahoma', sans-serif;
    }

    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      transition: opacity 0.5s ease;
    }

    #scene-container.fade-out {
      opacity: 0;
    }

    /* Controls hint */
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: #fff;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 12px 25px;
      border-radius: 8px;
      transition: opacity 0.3s;
      text-align: center;
    }

    .controls-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .controls-hint .main {
      font-size: 16px;
      margin-bottom: 5px;
    }

    .controls-hint .sub {
      font-size: 11px;
      color: #888;
    }

    /* Fullscreen desktop mode */
    .desktop-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .desktop-fullscreen.active {
      opacity: 1;
      pointer-events: auto;
    }

    .desktop-fullscreen iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Back button when in desktop mode */
    .back-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 1001;
      background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
      color: #fff;
      border: 2px solid #666;
      padding: 10px 20px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 5px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s, transform 0.2s;
      font-family: 'Tahoma', sans-serif;
    }

    .back-btn:hover {
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      transform: scale(1.05);
    }

    .back-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Screen glow overlay during transition */
    .screen-glow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, rgba(100,180,255,0.3) 0%, transparent 70%);
      z-index: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .screen-glow.active {
      opacity: 1;
    }

    /* Monitor highlight on hover */
    .click-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      background: rgba(0,100,200,0.8);
      padding: 15px 30px;
      border-radius: 10px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .click-hint.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- 3D Scene -->
  <div id="scene-container"></div>

  <!-- Controls hint -->
  <div class="controls-hint" id="controls-hint">
    <div class="main">Click the monitor to enter</div>
    <div class="sub">Drag to rotate • Scroll to zoom</div>
  </div>

  <!-- Click hint on monitor hover -->
  <div class="click-hint" id="click-hint">Click to Enter Desktop</div>

  <!-- Screen glow transition -->
  <div class="screen-glow" id="screen-glow"></div>

  <!-- Fullscreen desktop overlay -->
  <div class="desktop-fullscreen" id="desktop-fullscreen">
    <iframe src="desktop.html" id="desktop-iframe"></iframe>
  </div>

  <!-- Back button -->
  <button class="back-btn" id="back-btn" onclick="exitDesktop()">← Back to 3D View</button>

  <script>
    // ============ SATISFYING SOUNDS ============
    let audioCtx = null;
    let hissNode = null;
    let hissGain = null;

    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    // Preload sounds
    const sounds = {
      keypress: new Audio('sounds/keypress.mp3'),
      enter: new Audio('sounds/enter.ogg'),
      click: new Audio('sounds/open-window.ogg')
    };

    // Set volumes
    sounds.keypress.volume = 0.4;
    sounds.enter.volume = 0.5;
    sounds.click.volume = 0.3;

    // Mechanical keyboard sound
    function playKeySound() {
      try {
        const sound = sounds.keypress.cloneNode();
        sound.volume = 0.3 + Math.random() * 0.2;
        sound.playbackRate = 0.95 + Math.random() * 0.1;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Click sound
    function playClickSound() {
      try {
        const sound = sounds.click.cloneNode();
        sound.volume = 0.3;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Enter/confirmation sound
    function playEnterSound() {
      try {
        sounds.enter.currentTime = 0;
        sounds.enter.play().catch(() => {});
      } catch(e) {}
    }

    // Background hiss (CRT static)
    function startBackgroundHiss() {
      try {
        const ctx = getAudioCtx();
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        hissNode = ctx.createBufferSource();
        hissNode.buffer = noiseBuffer;
        hissNode.loop = true;

        // Filter to make it a softer hiss
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        hissGain = ctx.createGain();
        hissGain.gain.value = 0.015; // Very quiet

        hissNode.connect(filter);
        filter.connect(hissGain);
        hissGain.connect(ctx.destination);

        hissNode.start();
      } catch(e) {}
    }

    // Keyboard listener for mechanical sounds
    document.addEventListener('keydown', (e) => {
      if (!e.repeat) playKeySound();
    });

    // Click listener
    document.addEventListener('click', () => {
      playClickSound();
    });

    // Start hiss on first interaction
    let hissStarted = false;
    document.addEventListener('click', () => {
      if (!hissStarted) {
        hissStarted = true;
        startBackgroundHiss();
      }
    }, { once: true });

    // Three.js Scene
    let scene, camera, renderer, controls;
    let screenMesh; // Reference to clickable screen
    let isZooming = false;
    let isInDesktop = false;

    // Camera animation
    const startPos = { x: 0, y: 2, z: 4 };
    const endPos = { x: 0, y: 1.15, z: 0.8 }; // Close to screen
    const startTarget = { x: 0, y: 1, z: 0 };
    const endTarget = { x: 0, y: 1.15, z: 0.36 }; // Screen position

    // Raycaster for click detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(startPos.x, startPos.y, startPos.z);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('scene-container').appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 1.5;
      controls.maxDistance = 8;
      controls.maxPolarAngle = Math.PI / 2;
      controls.target.set(startTarget.x, startTarget.y, startTarget.z);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Add slight point light on screen for glow effect
      const screenLight = new THREE.PointLight(0x4488ff, 0.5, 3);
      screenLight.position.set(0, 1.15, 0.5);
      scene.add(screenLight);

      // Create scene objects
      createRoom();
      createDesk();
      createMonitor();
      createKeyboard();
      createMouse();
      createDecorations();

      // Mouse/click events
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      // Start animation
      animate();
    }

    // Floating bubbles array
    let bubbles = [];

    function createRoom() {
      // FRUTIGER AERO STYLE - Glossy grass floor
      const floorGeometry = new THREE.PlaneGeometry(20, 20);
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0x4CAF50, // Vibrant green grass
        roughness: 0.3,
        metalness: 0.1
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.5;
      floor.receiveShadow = true;
      scene.add(floor);

      // Glossy gradient sky sphere (instead of flat background)
      scene.background = null;
      const skyGeometry = new THREE.SphereGeometry(50, 32, 32);
      const skyCanvas = document.createElement('canvas');
      skyCanvas.width = 512;
      skyCanvas.height = 512;
      const skyCtx = skyCanvas.getContext('2d');

      // Frutiger Aero sky gradient - aqua to white
      const skyGrad = skyCtx.createLinearGradient(0, 0, 0, skyCanvas.height);
      skyGrad.addColorStop(0, '#87CEEB');
      skyGrad.addColorStop(0.3, '#B0E0E6');
      skyGrad.addColorStop(0.6, '#E0FFFF');
      skyGrad.addColorStop(1, '#F0FFFF');
      skyCtx.fillStyle = skyGrad;
      skyCtx.fillRect(0, 0, skyCanvas.width, skyCanvas.height);

      const skyTexture = new THREE.CanvasTexture(skyCanvas);
      const skyMaterial = new THREE.MeshBasicMaterial({
        map: skyTexture,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // Create floating bubbles for Frutiger Aero effect
      const bubbleMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.4,
        roughness: 0,
        metalness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0
      });

      for (let i = 0; i < 20; i++) {
        const size = 0.05 + Math.random() * 0.15;
        const bubbleGeo = new THREE.SphereGeometry(size, 16, 16);
        const bubble = new THREE.Mesh(bubbleGeo, bubbleMaterial);
        bubble.position.set(
          (Math.random() - 0.5) * 10,
          Math.random() * 5,
          (Math.random() - 0.5) * 10 - 2
        );
        bubble.userData = {
          speed: 0.002 + Math.random() * 0.005,
          xOffset: Math.random() * Math.PI * 2,
          zOffset: Math.random() * Math.PI * 2
        };
        bubbles.push(bubble);
        scene.add(bubble);
      }

      // Glossy white/glass back area (no wall, open feel)
      // Add some 3D grass blades
      const grassMaterial = new THREE.MeshStandardMaterial({
        color: 0x228B22,
        roughness: 0.6,
        side: THREE.DoubleSide
      });

      for (let i = 0; i < 50; i++) {
        const grassGeo = new THREE.ConeGeometry(0.02, 0.15 + Math.random() * 0.1, 4);
        const grass = new THREE.Mesh(grassGeo, grassMaterial);
        grass.position.set(
          (Math.random() - 0.5) * 8,
          -0.43,
          (Math.random() - 0.5) * 8
        );
        grass.rotation.x = (Math.random() - 0.5) * 0.3;
        scene.add(grass);
      }

      // Add some flowers for that nature-tech vibe
      const flowerColors = [0xFF69B4, 0xFFD700, 0xFF6347, 0x9370DB];
      for (let i = 0; i < 15; i++) {
        const flowerGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const flowerMat = new THREE.MeshStandardMaterial({
          color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
          roughness: 0.3
        });
        const flower = new THREE.Mesh(flowerGeo, flowerMat);
        flower.position.set(
          (Math.random() - 0.5) * 6,
          -0.4,
          (Math.random() - 0.5) * 6
        );
        scene.add(flower);
      }
    }

    function createDesk() {
      const deskMaterial = new THREE.MeshStandardMaterial({
        color: 0x5C4033,
        roughness: 0.7
      });

      // Desk top
      const deskTopGeometry = new THREE.BoxGeometry(3, 0.08, 1.5);
      const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
      deskTop.position.set(0, 0.5, 0);
      deskTop.castShadow = true;
      deskTop.receiveShadow = true;
      scene.add(deskTop);

      // Desk legs
      const legGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
      [[-1.4, 0, -0.65], [1.4, 0, -0.65], [-1.4, 0, 0.65], [1.4, 0, 0.65]].forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, deskMaterial);
        leg.position.set(...pos);
        leg.castShadow = true;
        scene.add(leg);
      });
    }

    function createMonitor() {
      const monitorColor = 0xD4C5A9;
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: monitorColor, roughness: 0.6 });

      // Main monitor body (CRT bulk)
      const bodyGeometry = new THREE.BoxGeometry(1.2, 1, 1);
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 1.1, -0.2);
      body.castShadow = true;
      scene.add(body);

      // Screen bezel (dark frame)
      const bezelGeometry = new THREE.BoxGeometry(1.0, 0.8, 0.05);
      const bezelMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3 });
      const bezel = new THREE.Mesh(bezelGeometry, bezelMaterial);
      bezel.position.set(0, 1.15, 0.33);
      scene.add(bezel);

      // Screen - THE CLICKABLE PART
      const screenGeometry = new THREE.PlaneGeometry(0.9, 0.68);

      // Create XP desktop texture
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 768;
      const ctx = canvas.getContext('2d');

      // XP Bliss background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#245EDC');
      gradient.addColorStop(0.4, '#3A7BD5');
      gradient.addColorStop(1, '#87CEEB');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Green rolling hills
      ctx.fillStyle = '#3CB043';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.quadraticCurveTo(canvas.width * 0.3, canvas.height * 0.5, canvas.width * 0.5, canvas.height * 0.6);
      ctx.quadraticCurveTo(canvas.width * 0.7, canvas.height * 0.7, canvas.width, canvas.height * 0.5);
      ctx.lineTo(canvas.width, canvas.height);
      ctx.fill();

      // Lighter hill in front
      ctx.fillStyle = '#4AE054';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.quadraticCurveTo(canvas.width * 0.5, canvas.height * 0.65, canvas.width, canvas.height);
      ctx.fill();

      // Clouds
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      [[150, 120, 50], [400, 80, 60], [700, 140, 45], [900, 100, 55]].forEach(([x, y, r]) => {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.arc(x + r*0.7, y - r*0.3, r*0.8, 0, Math.PI * 2);
        ctx.arc(x + r*1.3, y, r*0.9, 0, Math.PI * 2);
        ctx.fill();
      });

      // Desktop icons (simplified)
      ctx.fillStyle = '#fff';
      ctx.font = '14px Tahoma';
      const icons = ['My Computer', 'Recycle Bin', 'My Documents'];
      icons.forEach((name, i) => {
        ctx.fillRect(30, 30 + i * 80, 48, 48);
        ctx.fillStyle = '#000';
        ctx.fillText(name, 25, 95 + i * 80);
        ctx.fillStyle = '#fff';
      });

      // Taskbar
      ctx.fillStyle = '#245EDC';
      ctx.fillRect(0, canvas.height - 40, canvas.width, 40);

      // Start button
      ctx.fillStyle = '#3CB043';
      ctx.fillRect(5, canvas.height - 35, 80, 30);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Tahoma';
      ctx.fillText('start', 25, canvas.height - 15);

      const screenTexture = new THREE.CanvasTexture(canvas);
      const screenMaterial = new THREE.MeshBasicMaterial({ map: screenTexture });

      screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
      screenMesh.position.set(0, 1.15, 0.36);
      screenMesh.name = 'screen';
      scene.add(screenMesh);

      // Monitor stand
      const standGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.5);
      const stand = new THREE.Mesh(standGeometry, bodyMaterial);
      stand.position.set(0, 0.58, -0.2);
      stand.castShadow = true;
      scene.add(stand);

      // Monitor base
      const baseGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.4);
      const base = new THREE.Mesh(baseGeometry, bodyMaterial);
      base.position.set(0, 0.52, -0.1);
      base.castShadow = true;
      scene.add(base);

      // Power LED
      const ledGeometry = new THREE.CircleGeometry(0.015, 16);
      const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const led = new THREE.Mesh(ledGeometry, ledMaterial);
      led.position.set(0.4, 0.75, 0.31);
      scene.add(led);
    }

    function createKeyboard() {
      const kbMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });
      const keyMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4 });

      const kbGeometry = new THREE.BoxGeometry(0.6, 0.03, 0.2);
      const kb = new THREE.Mesh(kbGeometry, kbMaterial);
      kb.position.set(0, 0.56, 0.45);
      kb.castShadow = true;
      scene.add(kb);

      // Keys
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 12; col++) {
          const keyGeometry = new THREE.BoxGeometry(0.04, 0.015, 0.04);
          const key = new THREE.Mesh(keyGeometry, keyMaterial);
          key.position.set(-0.25 + col * 0.045, 0.58, 0.38 + row * 0.045);
          scene.add(key);
        }
      }
    }

    function createMouse() {
      const mouseMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });

      const mouseGeometry = new THREE.BoxGeometry(0.06, 0.025, 0.1);
      const mouseMesh = new THREE.Mesh(mouseGeometry, mouseMaterial);
      mouseMesh.position.set(0.5, 0.55, 0.45);
      mouseMesh.castShadow = true;
      scene.add(mouseMesh);

      // Cable
      const cableGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8);
      const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const cable = new THREE.Mesh(cableGeometry, cableMaterial);
      cable.position.set(0.5, 0.54, 0.25);
      cable.rotation.x = Math.PI / 2;
      scene.add(cable);
    }

    function createDecorations() {
      // Plant
      const potMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const potGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 8);
      const pot = new THREE.Mesh(potGeometry, potMaterial);
      pot.position.set(-1.2, 0.62, 0);
      pot.castShadow = true;
      scene.add(pot);

      const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
      for (let i = 0; i < 5; i++) {
        const leafGeometry = new THREE.ConeGeometry(0.03, 0.2, 4);
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(-1.2 + Math.cos(angle) * 0.05, 0.8, Math.sin(angle) * 0.05);
        leaf.rotation.x = 0.3 * Math.cos(angle);
        leaf.rotation.z = 0.3 * Math.sin(angle);
        scene.add(leaf);
      }

      // Coffee mug
      const mugMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3 });
      const mugGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.1, 16);
      const mug = new THREE.Mesh(mugGeometry, mugMaterial);
      mug.position.set(1.1, 0.59, 0.3);
      mug.castShadow = true;
      scene.add(mug);

      const coffeeGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const coffeeMaterial = new THREE.MeshStandardMaterial({ color: 0x3C1810, roughness: 0.2 });
      const coffee = new THREE.Mesh(coffeeGeometry, coffeeMaterial);
      coffee.position.set(1.1, 0.63, 0.3);
      scene.add(coffee);

      // Picture frame on wall
      const frameGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.02);
      const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
      const frame = new THREE.Mesh(frameGeometry, frameMaterial);
      frame.position.set(-0.8, 2, -4.98);
      scene.add(frame);

      // Photo inside frame
      const photoGeometry = new THREE.PlaneGeometry(0.4, 0.3);
      const photoMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB });
      const photo = new THREE.Mesh(photoGeometry, photoMaterial);
      photo.position.set(-0.8, 2, -4.96);
      scene.add(photo);
    }

    // Mouse move - check if hovering screen
    function onMouseMove(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      const hint = document.getElementById('click-hint');
      if (intersects.length > 0) {
        hint.classList.add('visible');
        document.body.style.cursor = 'pointer';
      } else {
        hint.classList.remove('visible');
        document.body.style.cursor = 'grab';
      }
    }

    // Click - zoom into screen
    function onMouseClick(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      if (intersects.length > 0) {
        zoomIntoScreen();
      }
    }

    // Smooth zoom animation into screen
    function zoomIntoScreen() {
      isZooming = true;
      controls.enabled = false;
      playEnterSound(); // Play enter sound

      // Hide UI
      document.getElementById('click-hint').classList.remove('visible');
      document.getElementById('controls-hint').classList.add('hidden');
      document.body.style.cursor = 'default';

      // Get current camera state
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const startTargetPos = { x: controls.target.x, y: controls.target.y, z: controls.target.z };

      const duration = 1500; // ms
      const startTime = Date.now();

      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function (ease-in-out)
        const eased = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        // Interpolate camera position
        camera.position.x = startCamPos.x + (endPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (endPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (endPos.z - startCamPos.z) * eased;

        // Interpolate target
        controls.target.x = startTargetPos.x + (endTarget.x - startTargetPos.x) * eased;
        controls.target.y = startTargetPos.y + (endTarget.y - startTargetPos.y) * eased;
        controls.target.z = startTargetPos.z + (endTarget.z - startTargetPos.z) * eased;

        camera.lookAt(controls.target);

        // Fade in screen glow at 50%
        if (progress > 0.5) {
          document.getElementById('screen-glow').classList.add('active');
        }

        // Fade out 3D scene at 80%
        if (progress > 0.8) {
          document.getElementById('scene-container').classList.add('fade-out');
        }

        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        } else {
          // Complete - show desktop
          setTimeout(() => {
            document.getElementById('desktop-fullscreen').classList.add('active');
            document.getElementById('back-btn').classList.add('active');
            document.getElementById('screen-glow').classList.remove('active');
            isZooming = false;
            isInDesktop = true;
          }, 300);
        }
      }

      animateZoom();
    }

    // Exit desktop - zoom back out
    function exitDesktop() {
      document.getElementById('desktop-fullscreen').classList.remove('active');
      document.getElementById('back-btn').classList.remove('active');
      document.getElementById('scene-container').classList.remove('fade-out');

      // Reset camera position
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const duration = 800;
      const startTime = Date.now();

      function animateZoomOut() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // ease-out

        camera.position.x = startCamPos.x + (startPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (startPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (startPos.z - startCamPos.z) * eased;

        controls.target.x = endTarget.x + (startTarget.x - endTarget.x) * eased;
        controls.target.y = endTarget.y + (startTarget.y - endTarget.y) * eased;
        controls.target.z = endTarget.z + (startTarget.z - endTarget.z) * eased;

        camera.lookAt(controls.target);

        if (progress < 1) {
          requestAnimationFrame(animateZoomOut);
        } else {
          controls.enabled = true;
          isInDesktop = false;

          // Show UI again
          document.getElementById('controls-hint').classList.remove('hidden');
        }
      }

      animateZoomOut();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (!isZooming) {
        controls.update();
      }

      // Animate floating bubbles
      const time = Date.now() * 0.001;
      bubbles.forEach(bubble => {
        bubble.position.y += bubble.userData.speed;
        bubble.position.x += Math.sin(time + bubble.userData.xOffset) * 0.002;
        bubble.position.z += Math.cos(time + bubble.userData.zOffset) * 0.002;

        // Reset bubble when too high
        if (bubble.position.y > 6) {
          bubble.position.y = -0.5;
          bubble.position.x = (Math.random() - 0.5) * 10;
          bubble.position.z = (Math.random() - 0.5) * 10 - 2;
        }
      });

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize);

    // ESC to exit desktop
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isInDesktop) {
        exitDesktop();
      }
    });

    // Listen for messages from iframe (e.g., shutdown -> power on)
    window.addEventListener('message', (e) => {
      if (e.data === 'exitDesktop' && isInDesktop) {
        exitDesktop();
      }
    });

    // Initialize
    init();
  </script>
</body>
</html>
