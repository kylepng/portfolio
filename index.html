<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyle | 3D Desktop</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='r' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ff5f5f'/%3E%3Cstop offset='100%25' stop-color='%23cc0000'/%3E%3C/linearGradient%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2355ff55'/%3E%3Cstop offset='100%25' stop-color='%2300aa00'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%235599ff'/%3E%3Cstop offset='100%25' stop-color='%230044cc'/%3E%3C/linearGradient%3E%3ClinearGradient id='y' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffee55'/%3E%3Cstop offset='100%25' stop-color='%23ccaa00'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x='2' y='2' width='13' height='13' rx='2' fill='url(%23r)'/%3E%3Crect x='17' y='2' width='13' height='13' rx='2' fill='url(%23g)'/%3E%3Crect x='2' y='17' width='13' height='13' rx='2' fill='url(%23b)'/%3E%3Crect x='17' y='17' width='13' height='13' rx='2' fill='url(%23y)'/%3E%3C/svg%3E">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <!-- YouTube API only needed in desktop.html -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Tahoma', sans-serif;
    }

    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      transition: opacity 0.5s ease;
    }

    #scene-container.fade-out {
      opacity: 0;
    }

    /* Controls hint */
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: #fff;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 12px 25px;
      border-radius: 8px;
      transition: opacity 0.3s;
      text-align: center;
    }

    .controls-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .controls-hint .main {
      font-size: 16px;
      margin-bottom: 5px;
    }

    .controls-hint .sub {
      font-size: 11px;
      color: #888;
    }

    /* Fullscreen desktop mode */
    .desktop-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .desktop-fullscreen.active {
      opacity: 1;
      pointer-events: auto;
    }

    .desktop-fullscreen iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Back button when in desktop mode */
    .back-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 1001;
      background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
      color: #fff;
      border: 2px solid #666;
      padding: 10px 20px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 5px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s, transform 0.2s;
      font-family: 'Tahoma', sans-serif;
    }

    .back-btn:hover {
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      transform: scale(1.05);
    }

    .back-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Screen glow overlay during transition */
    .screen-glow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, rgba(100,180,255,0.3) 0%, transparent 70%);
      z-index: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .screen-glow.active {
      opacity: 1;
    }

    /* Monitor highlight on hover */
    .click-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      background: rgba(0,100,200,0.8);
      padding: 15px 30px;
      border-radius: 10px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .click-hint.visible {
      opacity: 1;
    }
      /* Mobile overlay */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      z-index: 9999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }

    .mobile-overlay.show {
      display: flex;
    }

    .mobile-overlay h1 {
      color: #fff;
      font-size: 28px;
      margin-bottom: 10px;
    }

    .mobile-overlay p {
      color: #888;
      font-size: 14px;
      max-width: 300px;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .mobile-overlay .links {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 280px;
    }

    .mobile-overlay a {
      background: linear-gradient(180deg, #5b8def 0%, #3a6bc5 100%);
      color: #fff;
      text-decoration: none;
      padding: 14px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .mobile-overlay .skip-btn {
      background: transparent;
      border: 1px solid #444;
      color: #666;
      padding: 10px;
      margin-top: 20px;
      cursor: pointer;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      .mobile-overlay {
        display: flex;
      }
    }

  </style>
</head>
<body>
  <!-- Mobile Overlay -->
  <div class="mobile-overlay" id="mobile-overlay">
    <h1>Kyle K.</h1>
    <p>This portfolio is best experienced on desktop. It features a 3D interactive room with a Windows XP desktop simulation.</p>
    <div class="links">
      <a href="https://github.com/ergophobian" target="_blank">GitHub @ergophobian</a>
      <a href="https://tiktok.com/@ergophobian" target="_blank">TikTok @ergophobian</a>
      <a href="https://x.com/indefatigabile" target="_blank">X @indefatigabile</a>
    </div>
    <button class="skip-btn" onclick="document.getElementById('mobile-overlay').classList.remove('show');">
      Continue to desktop version anyway
    </button>
  </div>

  <!-- 3D Scene -->
  <div id="scene-container"></div>

  <!-- Controls hint -->
  <div class="controls-hint" id="controls-hint">
    <div class="main">Click the monitor to enter</div>
    <div class="sub">Drag to rotate • Scroll to zoom</div>
  </div>

  <!-- Click hint on monitor hover -->
  <div class="click-hint" id="click-hint">Click to Enter Desktop</div>

  <!-- Screen glow transition -->
  <div class="screen-glow" id="screen-glow"></div>

  <!-- Fullscreen desktop overlay -->
  <div class="desktop-fullscreen" id="desktop-fullscreen">
    <iframe src="desktop.html" id="desktop-iframe"></iframe>
  </div>

  <!-- Back button -->
  <button class="back-btn" id="back-btn" onclick="exitDesktop()">← Back to 3D View</button>


  <script>
    // ============ SATISFYING SOUNDS ============
    let audioCtx = null;
    let hissNode = null;
    let hissGain = null;

    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    // Preload sounds
    const sounds = {
      keypress: new Audio('sounds/keypress.mp3'),
      enter: new Audio('sounds/enter.ogg'),
      click: new Audio('sounds/open-window.ogg')
    };

    // Set volumes
    sounds.keypress.volume = 0.4;
    sounds.enter.volume = 0.5;
    sounds.click.volume = 0.3;

    // Mechanical keyboard sound
    function playKeySound() {
      try {
        const sound = sounds.keypress.cloneNode();
        sound.volume = 0.3 + Math.random() * 0.2;
        sound.playbackRate = 0.95 + Math.random() * 0.1;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Click sound
    function playClickSound() {
      try {
        const sound = sounds.click.cloneNode();
        sound.volume = 0.3;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Enter/confirmation sound
    function playEnterSound() {
      try {
        sounds.enter.currentTime = 0;
        sounds.enter.play().catch(() => {});
      } catch(e) {}
    }

    // Background hiss (CRT static)
    function startBackgroundHiss() {
      try {
        const ctx = getAudioCtx();
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        hissNode = ctx.createBufferSource();
        hissNode.buffer = noiseBuffer;
        hissNode.loop = true;

        // Filter to make it a softer hiss
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        hissGain = ctx.createGain();
        hissGain.gain.value = 0.015; // Very quiet

        hissNode.connect(filter);
        filter.connect(hissGain);
        hissGain.connect(ctx.destination);

        hissNode.start();
      } catch(e) {}
    }

    // Keyboard listener for mechanical sounds (only when in desktop mode)
    document.addEventListener('keydown', (e) => {
      if (!e.repeat && isInDesktop) playKeySound();
    });

    // Start hiss on first interaction (very subtle)
    let hissStarted = false;
    function maybeStartHiss() {
      if (!hissStarted) {
        hissStarted = true;
        startBackgroundHiss();
      }
    }

    // Three.js Scene
    let scene, camera, renderer, controls, composer, fxaaPass;
    let screenMesh; // Reference to clickable screen
    let screenLight; // Screen glow light (for flicker)
    let steamParticles = []; // Coffee steam particles
    let isZooming = false;
    let isInDesktop = false;

    // Camera animation
    const startPos = { x: 0, y: 2, z: 4 };
    const endPos = { x: 0, y: 1.15, z: 0.8 }; // Close to screen
    const startTarget = { x: 0, y: 1, z: 0 };
    const endTarget = { x: 0, y: 1.15, z: 0.36 }; // Screen position

    // Raycaster for click detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(startPos.x, startPos.y, startPos.z);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('scene-container').appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 1.5;
      controls.maxDistance = 8;
      controls.maxPolarAngle = Math.PI / 2;
      controls.target.set(startTarget.x, startTarget.y, startTarget.z);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Hemisphere light (sky blue top, warm brown bottom)
      const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3B2507, 0.4);
      scene.add(hemiLight);

      // Add slight point light on screen for glow effect
      screenLight = new THREE.PointLight(0x4488ff, 0.5, 3);
      screenLight.position.set(0, 1.15, 0.5);
      scene.add(screenLight);

      // Rim light behind monitor
      const rimLight = new THREE.PointLight(0x4488ff, 0.8, 4);
      rimLight.position.set(0, 1.5, -0.5);
      scene.add(rimLight);

      // Warm fill light
      const warmFill = new THREE.PointLight(0xffaa44, 0.3, 5);
      warmFill.position.set(-2, 2, 1);
      scene.add(warmFill);

      // Fog
      scene.fog = new THREE.FogExp2(0x87CEEB, 0.02);

      // Create scene objects
      createRoom();
      createDesk();
      createMonitor();
      createKeyboard();
      createMouse();
      createDecorations();
      createCats();
      createSleepingPerson();
      createDog();
      createRabbits();
      createSquirrels();
      createBirds();
      createTrees();
      createRocks();
      createPond();
      createFallingLeaves();

      // Mouse/click events
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      // Post-processing pipeline (with fallback to basic rendering)
      try {
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));

        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.3,  // strength (subtle)
          0.4,  // radius
          0.85  // threshold
        );
        composer.addPass(bloomPass);

        // FXAA anti-aliasing
        fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(fxaaPass);
      } catch (e) {
        console.warn('Post-processing failed, using basic renderer:', e);
        composer = null;
      }

      // Start animation
      animate();
    }

    // Floating clouds array
    let clouds = [];
    // Butterflies array
    let butterflies = [];
    // Birds array
    let birds = [];
    // Trees array
    let trees = [];
    // Falling leaves array
    let fallingLeaves = [];
    // Pond reference
    let pond = null;
    let pondGeometry = null;

    function createRoom() {
      // WINDOWS XP BLISS - Authentic rolling green hills

      // Create smooth hilly terrain with higher resolution
      const terrainGeometry = new THREE.PlaneGeometry(60, 60, 128, 128);
      const vertices = terrainGeometry.attributes.position.array;

      // Smooth rolling hills - authentic XP Bliss feel
      // Flatten terrain near the desk so objects sit on the ground properly
      const deskGroundHeight = 0.5; // Flattened ground near desk = terrain_y(-0.5) + 0.5 = 0.0
      const flattenRadius = 5; // Radius of flat area around desk
      for (let i = 0; i < vertices.length; i += 3) {
        const x = vertices[i];
        const y = vertices[i + 1];
        // Multiple sine waves for natural rolling hills
        const hill1 = Math.sin(x * 0.15) * Math.cos(y * 0.1) * 0.8;
        const hill2 = Math.sin(x * 0.08 + 0.5) * Math.sin(y * 0.12) * 0.5;
        const hill3 = Math.cos(x * 0.05 + y * 0.05) * 0.6;
        const micro = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.05;
        const hillHeight = hill1 + hill2 + hill3 + micro;
        // Smooth blend: flat near desk, hills further out
        const dist = Math.sqrt(x * x + y * y);
        const blend = dist < flattenRadius ? Math.pow(dist / flattenRadius, 2) : 1;
        vertices[i + 2] = deskGroundHeight + (hillHeight - deskGroundHeight) * blend;
      }
      terrainGeometry.computeVertexNormals();

      // Create grass texture procedurally
      const grassCanvas = document.createElement('canvas');
      grassCanvas.width = 512;
      grassCanvas.height = 512;
      const grassCtx = grassCanvas.getContext('2d');

      // Base grass color
      grassCtx.fillStyle = '#3CB043';
      grassCtx.fillRect(0, 0, 512, 512);

      // Add grass blade details
      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const shade = Math.random() * 0.3;
        const green = Math.floor(160 + Math.random() * 60);
        grassCtx.fillStyle = `rgb(${30 + shade * 30}, ${green}, ${30 + shade * 20})`;
        grassCtx.fillRect(x, y, 2, 4 + Math.random() * 4);
      }

      // Add lighter highlights
      for (let i = 0; i < 500; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        grassCtx.fillStyle = 'rgba(100, 200, 100, 0.3)';
        grassCtx.fillRect(x, y, 3, 3);
      }

      const grassTexture = new THREE.CanvasTexture(grassCanvas);
      grassTexture.wrapS = THREE.RepeatWrapping;
      grassTexture.wrapT = THREE.RepeatWrapping;
      grassTexture.repeat.set(20, 20);

      const terrainMaterial = new THREE.MeshStandardMaterial({
        map: grassTexture,
        roughness: 0.9,
        metalness: 0,
        flatShading: false
      });
      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrain.rotation.x = -Math.PI / 2;
      terrain.position.y = -0.5;
      terrain.receiveShadow = true;
      scene.add(terrain);

      // Add grass tufts for texture
      createGrassTufts();

      // Add wildflowers
      createWildflowers();

      // === WINDOWS XP BLISS SKY ===
      scene.background = null;
      const skyGeometry = new THREE.SphereGeometry(80, 64, 64);
      const skyCanvas = document.createElement('canvas');
      skyCanvas.width = 2048;
      skyCanvas.height = 1024;
      const skyCtx = skyCanvas.getContext('2d');

      // Authentic XP Bliss sky gradient
      const skyGrad = skyCtx.createLinearGradient(0, 0, 0, skyCanvas.height);
      skyGrad.addColorStop(0, '#1565C0');     // Deep blue at zenith
      skyGrad.addColorStop(0.15, '#1E88E5');  // Rich blue
      skyGrad.addColorStop(0.3, '#42A5F5');   // Medium blue
      skyGrad.addColorStop(0.45, '#64B5F6');  // Lighter blue
      skyGrad.addColorStop(0.6, '#90CAF9');   // Light blue
      skyGrad.addColorStop(0.75, '#BBDEFB');  // Very light blue
      skyGrad.addColorStop(0.9, '#E3F2FD');   // Near white at horizon
      skyGrad.addColorStop(1, '#F5F9FF');     // White horizon
      skyCtx.fillStyle = skyGrad;
      skyCtx.fillRect(0, 0, skyCanvas.width, skyCanvas.height);

      // Draw fluffy cumulus clouds on sky texture
      function drawCloud(ctx, x, y, scale) {
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        const s = scale;
        // Multiple overlapping circles for fluffy appearance
        ctx.beginPath();
        ctx.arc(x, y, 35*s, 0, Math.PI * 2);
        ctx.arc(x + 30*s, y - 15*s, 30*s, 0, Math.PI * 2);
        ctx.arc(x + 55*s, y - 5*s, 32*s, 0, Math.PI * 2);
        ctx.arc(x + 80*s, y, 28*s, 0, Math.PI * 2);
        ctx.arc(x + 25*s, y + 12*s, 25*s, 0, Math.PI * 2);
        ctx.arc(x + 55*s, y + 15*s, 27*s, 0, Math.PI * 2);
        ctx.arc(x + 40*s, y - 8*s, 28*s, 0, Math.PI * 2);
        ctx.fill();

        // Subtle shadow on bottom of cloud
        ctx.fillStyle = 'rgba(200,210,220,0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 40*s, y + 20*s, 50*s, 12*s, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // Scattered clouds across the sky
      drawCloud(skyCtx, 150, 200, 1.2);
      drawCloud(skyCtx, 500, 150, 1.5);
      drawCloud(skyCtx, 900, 220, 1.1);
      drawCloud(skyCtx, 1300, 180, 1.4);
      drawCloud(skyCtx, 1700, 160, 1.3);
      drawCloud(skyCtx, 300, 350, 0.9);
      drawCloud(skyCtx, 750, 380, 1.0);
      drawCloud(skyCtx, 1150, 340, 1.1);
      drawCloud(skyCtx, 1550, 370, 0.95);
      drawCloud(skyCtx, 1900, 320, 1.2);

      const skyTexture = new THREE.CanvasTexture(skyCanvas);
      skyTexture.minFilter = THREE.LinearFilter;
      const skyMaterial = new THREE.MeshBasicMaterial({
        map: skyTexture,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // === 3D FLOATING CLOUDS - Big and prominent ===
      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.98,
        roughness: 1,
        metalness: 0,
        emissive: 0xffffff,
        emissiveIntensity: 0.1
      });

      // Create big fluffy clouds - closer and more visible
      const cloudConfigs = [
        { x: -8, y: 6, z: -5, scale: 2.5 },
        { x: 8, y: 7, z: -8, scale: 3 },
        { x: 0, y: 8, z: -12, scale: 4 },
        { x: -15, y: 5, z: -6, scale: 2 },
        { x: 15, y: 6, z: -10, scale: 2.5 },
        { x: -5, y: 9, z: -15, scale: 3 },
        { x: 12, y: 8, z: -18, scale: 3.5 },
        { x: -12, y: 7, z: -20, scale: 3 },
        { x: 5, y: 10, z: -25, scale: 4 },
        { x: -8, y: 11, z: -22, scale: 3.5 },
      ];

      cloudConfigs.forEach((config, i) => {
        const cloudGroup = new THREE.Group();
        const numPuffs = 6 + Math.floor(Math.random() * 5);

        for (let j = 0; j < numPuffs; j++) {
          const size = (0.4 + Math.random() * 0.5) * config.scale * 0.3;
          const puff = new THREE.Mesh(new THREE.SphereGeometry(size, 16, 16), cloudMaterial);
          puff.position.set(
            (j - numPuffs/2) * 0.4 * config.scale * 0.3 + Math.random() * 0.3,
            Math.random() * 0.3 * config.scale * 0.3,
            Math.random() * 0.4 * config.scale * 0.3 - 0.2
          );
          puff.scale.y = 0.5 + Math.random() * 0.3;
          cloudGroup.add(puff);
        }

        cloudGroup.position.set(config.x, config.y, config.z);
        cloudGroup.userData = {
          speed: 0.002 + Math.random() * 0.005,
          startX: config.x
        };
        clouds.push(cloudGroup);
        scene.add(cloudGroup);
      });

      // Create butterflies
      createButterflies();
    }

    function createGrassTufts() {
      // Scattered grass tufts for texture
      const grassMaterial = new THREE.MeshStandardMaterial({
        color: 0x2E7D32,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      for (let i = 0; i < 100; i++) {
        const tuft = new THREE.Group();
        // Each tuft has 3-5 blades
        const numBlades = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < numBlades; j++) {
          const blade = new THREE.Mesh(
            new THREE.ConeGeometry(0.015, 0.1 + Math.random() * 0.05, 4),
            grassMaterial
          );
          blade.position.set(
            (Math.random() - 0.5) * 0.05,
            0.04,
            (Math.random() - 0.5) * 0.05
          );
          blade.rotation.x = (Math.random() - 0.5) * 0.3;
          blade.rotation.z = (Math.random() - 0.5) * 0.3;
          tuft.add(blade);
        }
        tuft.position.set(
          (Math.random() - 0.5) * 15,
          -0.1,
          (Math.random() - 0.5) * 15
        );
        scene.add(tuft);
      }
    }

    function createWildflowers() {
      // Scattered wildflowers like in Windows XP Bliss
      const flowerColors = [0xFFEB3B, 0xFFFFFF, 0xFF7043, 0xE91E63, 0x9C27B0, 0xFF5722, 0xAB47BC];

      // Regular wildflowers (80 now)
      for (let i = 0; i < 80; i++) {
        const flower = new THREE.Group();
        const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];

        // Stem
        const stem = new THREE.Mesh(
          new THREE.CylinderGeometry(0.005, 0.005, 0.08 + Math.random() * 0.04, 6),
          new THREE.MeshStandardMaterial({ color: 0x33691E })
        );
        stem.position.y = 0.04;
        flower.add(stem);

        // Petals (simple)
        const petalMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
        for (let p = 0; p < 5; p++) {
          const petal = new THREE.Mesh(
            new THREE.SphereGeometry(0.015, 6, 6),
            petalMat
          );
          const angle = (p / 5) * Math.PI * 2;
          petal.position.set(
            Math.cos(angle) * 0.02,
            0.085,
            Math.sin(angle) * 0.02
          );
          petal.scale.y = 0.5;
          flower.add(petal);
        }

        // Center
        const center = new THREE.Mesh(
          new THREE.SphereGeometry(0.01, 6, 6),
          new THREE.MeshStandardMaterial({ color: 0xFFC107 })
        );
        center.position.y = 0.085;
        flower.add(center);

        flower.position.set(
          (Math.random() - 0.5) * 12,
          -0.1,
          (Math.random() - 0.5) * 12
        );
        scene.add(flower);
      }

      // === SUNFLOWERS (3-4 tall ones) ===
      const sunflowerPositions = [
        { x: -2.5, z: 2.5 }, { x: 3.5, z: 1.5 }, { x: -4, z: -1.5 }, { x: 5, z: 3 }
      ];
      const stemMat = new THREE.MeshStandardMaterial({ color: 0x33691E, roughness: 0.8 });
      const sunPetalMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.7 });
      const sunCenterMat = new THREE.MeshStandardMaterial({ color: 0x5D3A1A, roughness: 0.9 });

      sunflowerPositions.forEach(sp => {
        const sfGroup = new THREE.Group();
        const stemH = 0.25 + Math.random() * 0.1;

        // Tall stem
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.01, stemH, 6), stemMat);
        stem.position.y = stemH / 2;
        sfGroup.add(stem);

        // Leaf on stem
        const leafGeo = new THREE.SphereGeometry(0.03, 6, 4);
        const leafMesh = new THREE.Mesh(leafGeo, stemMat);
        leafMesh.scale.set(1.5, 0.3, 1.0);
        leafMesh.position.set(0.02, stemH * 0.5, 0);
        leafMesh.rotation.z = -0.5;
        sfGroup.add(leafMesh);

        // Flower head - face disc
        const faceY = stemH + 0.04;

        // Petals (12 arranged in circle)
        for (let p = 0; p < 12; p++) {
          const angle = (p / 12) * Math.PI * 2;
          const petal = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 4), sunPetalMat);
          petal.scale.set(0.6, 0.3, 1.5);
          petal.position.set(Math.cos(angle) * 0.04, faceY, Math.sin(angle) * 0.04);
          petal.rotation.y = -angle;
          sfGroup.add(petal);
        }

        // Brown center
        const center = new THREE.Mesh(new THREE.SphereGeometry(0.03, 10, 8), sunCenterMat);
        center.scale.y = 0.5;
        center.position.y = faceY;
        sfGroup.add(center);

        sfGroup.position.set(sp.x, -0.1, sp.z);
        scene.add(sfGroup);
      });

      // === DANDELIONS (10 white puff balls) ===
      const puffMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, roughness: 1 });
      for (let i = 0; i < 10; i++) {
        const dandelion = new THREE.Group();

        // Thin stem
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.1, 4), stemMat);
        stem.position.y = 0.05;
        dandelion.add(stem);

        // Puff ball
        const puff = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 6), puffMat);
        puff.position.y = 0.11;
        dandelion.add(puff);

        dandelion.position.set(
          (Math.random() - 0.5) * 10,
          -0.1,
          (Math.random() - 0.5) * 10
        );
        scene.add(dandelion);
      }

      // === TALLER GRASS PATCHES ===
      const tallGrassMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.9, side: THREE.DoubleSide });
      for (let i = 0; i < 15; i++) {
        const patchX = (Math.random() - 0.5) * 12;
        const patchZ = (Math.random() - 0.5) * 12;
        const numBlades = 5 + Math.floor(Math.random() * 4);
        for (let j = 0; j < numBlades; j++) {
          const bladeH = 0.15 + Math.random() * 0.15;
          const blade = new THREE.Mesh(new THREE.ConeGeometry(0.01, bladeH, 4), tallGrassMat);
          blade.position.set(
            patchX + (Math.random() - 0.5) * 0.1,
            -0.1 + bladeH / 2,
            patchZ + (Math.random() - 0.5) * 0.1
          );
          blade.rotation.x = (Math.random() - 0.5) * 0.3;
          blade.rotation.z = (Math.random() - 0.5) * 0.3;
          scene.add(blade);
        }
      }
    }

    function createButterflies() {
      // Animated butterflies floating around
      const butterflyColors = [0xFF9800, 0x2196F3, 0xFFEB3B, 0xE91E63];

      for (let i = 0; i < 6; i++) {
        const butterfly = new THREE.Group();
        const color = butterflyColors[Math.floor(Math.random() * butterflyColors.length)];
        const wingMat = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          side: THREE.DoubleSide
        });

        // Wings (simple triangular shapes)
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(0.03, 0.02);
        wingShape.lineTo(0.025, -0.02);
        wingShape.lineTo(0, 0);

        const wingGeo = new THREE.ShapeGeometry(wingShape);

        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.x = 0.005;
        butterfly.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.scale.x = -1;
        rightWing.position.x = -0.005;
        butterfly.add(rightWing);

        // Body
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.003, 0.002, 0.025, 6),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        body.rotation.x = Math.PI / 2;
        butterfly.add(body);

        butterfly.position.set(
          (Math.random() - 0.5) * 6,
          0.5 + Math.random() * 1.5,
          (Math.random() - 0.5) * 6
        );

        butterfly.userData = {
          baseY: butterfly.position.y,
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 0.5,
          radius: 0.5 + Math.random() * 1,
          wingPhase: Math.random() * Math.PI * 2
        };

        butterflies.push(butterfly);
        scene.add(butterfly);
      }
    }

    // Cats array
    let cats = [];
    let dog = null;
    let rabbits = [];
    let squirrels = [];
    let sleepingPerson = null;

    // Compute terrain surface height at any world position
    function getTerrainHeight(wx, wz) {
      const x = wx;
      const y = -wz; // terrain local y = -world z (due to rotateX(-PI/2))
      const hill1 = Math.sin(x * 0.15) * Math.cos(y * 0.1) * 0.8;
      const hill2 = Math.sin(x * 0.08 + 0.5) * Math.sin(y * 0.12) * 0.5;
      const hill3 = Math.cos(x * 0.05 + y * 0.05) * 0.6;
      const micro = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.05;
      const hillHeight = hill1 + hill2 + hill3 + micro;
      const dist = Math.sqrt(x * x + y * y);
      const deskGroundHeight = 0.5;
      const flattenRadius = 5;
      const blend = dist < flattenRadius ? Math.pow(dist / flattenRadius, 2) : 1;
      const displacement = deskGroundHeight + (hillHeight - deskGroundHeight) * blend;
      return -0.5 + displacement;
    }

    function createCats() {
      // 3 cats: orange tabby, tuxedo black/white, gray
      const catConfigs = [
        { bodyColor: 0xE8935A, name: 'orange' },
        { bodyColor: 0x222222, chestColor: 0xFFFFFF, name: 'tuxedo' },
        { bodyColor: 0x888888, name: 'gray' }
      ];

      catConfigs.forEach((config, i) => {
        const catGroup = new THREE.Group();
        const catMat = new THREE.MeshStandardMaterial({ color: config.bodyColor, roughness: 0.85 });
        const chestMat = config.chestColor
          ? new THREE.MeshStandardMaterial({ color: config.chestColor, roughness: 0.85 })
          : catMat;
        const pinkMat = new THREE.MeshStandardMaterial({ color: 0xFFB6C1, roughness: 0.7 });
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
        const eyeHighlight = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const noseMat = new THREE.MeshStandardMaterial({ color: 0xFF9999, roughness: 0.5 });
        const whiskerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5 });

        // === BODY (multiple spheres for smoother shape) ===
        // Main body
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 10), catMat);
        body.scale.set(1.6, 0.9, 1.0);
        body.position.set(0, 0.14, 0);
        body.name = 'catBody';
        catGroup.add(body);

        // Chest (front of body, slightly lower)
        const chest = new THREE.Mesh(new THREE.SphereGeometry(0.09, 10, 8), chestMat);
        chest.scale.set(1.0, 0.85, 0.9);
        chest.position.set(0.1, 0.12, 0);
        catGroup.add(chest);

        // Haunches (rear, slightly larger)
        const haunch = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), catMat);
        haunch.scale.set(1.0, 0.9, 1.1);
        haunch.position.set(-0.1, 0.13, 0);
        catGroup.add(haunch);

        // === HEAD (sphere + cheek puffs) ===
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 10), catMat);
        head.position.set(0.22, 0.2, 0);
        head.name = 'catHead';
        catGroup.add(head);

        // Cheek puffs
        const cheekL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), catMat);
        cheekL.position.set(0.24, 0.17, 0.05);
        catGroup.add(cheekL);
        const cheekR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), catMat);
        cheekR.position.set(0.24, 0.17, -0.05);
        catGroup.add(cheekR);

        // Muzzle bump
        const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 6), chestMat);
        muzzle.scale.set(0.7, 0.6, 0.8);
        muzzle.position.set(0.3, 0.17, 0);
        catGroup.add(muzzle);

        // === EARS (cones with inner pink) ===
        const earGeo = new THREE.ConeGeometry(0.035, 0.07, 4);
        const earInnerGeo = new THREE.ConeGeometry(0.02, 0.045, 4);

        const ear1 = new THREE.Mesh(earGeo, catMat);
        ear1.position.set(0.24, 0.3, 0.045);
        ear1.rotation.z = -0.15;
        ear1.rotation.x = -0.1;
        catGroup.add(ear1);
        const ear1Inner = new THREE.Mesh(earInnerGeo, pinkMat);
        ear1Inner.position.set(0.245, 0.295, 0.045);
        ear1Inner.rotation.z = -0.15;
        ear1Inner.rotation.x = -0.1;
        catGroup.add(ear1Inner);

        const ear2 = new THREE.Mesh(earGeo, catMat);
        ear2.position.set(0.24, 0.3, -0.045);
        ear2.rotation.z = -0.15;
        ear2.rotation.x = 0.1;
        catGroup.add(ear2);
        const ear2Inner = new THREE.Mesh(earInnerGeo, pinkMat);
        ear2Inner.position.set(0.245, 0.295, -0.045);
        ear2Inner.rotation.z = -0.15;
        ear2Inner.rotation.x = 0.1;
        catGroup.add(ear2Inner);

        // === EYES ===
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.018, 8, 6), eyeMat);
        eyeL.position.set(0.3, 0.22, 0.035);
        catGroup.add(eyeL);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.018, 8, 6), eyeMat);
        eyeR.position.set(0.3, 0.22, -0.035);
        catGroup.add(eyeR);

        // Eye highlights
        const hlL = new THREE.Mesh(new THREE.SphereGeometry(0.006, 6, 4), eyeHighlight);
        hlL.position.set(0.315, 0.225, 0.03);
        catGroup.add(hlL);
        const hlR = new THREE.Mesh(new THREE.SphereGeometry(0.006, 6, 4), eyeHighlight);
        hlR.position.set(0.315, 0.225, -0.03);
        catGroup.add(hlR);

        // === NOSE ===
        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.01, 6, 6), noseMat);
        nose.scale.set(1.2, 0.8, 1.0);
        nose.position.set(0.32, 0.19, 0);
        catGroup.add(nose);

        // === WHISKERS (3 per side) ===
        for (let w = 0; w < 3; w++) {
          const whiskerGeo = new THREE.CylinderGeometry(0.002, 0.001, 0.08, 4);
          const wL = new THREE.Mesh(whiskerGeo, whiskerMat);
          wL.position.set(0.3, 0.175 + w * 0.012, 0.06);
          wL.rotation.z = Math.PI / 2;
          wL.rotation.x = -0.2 + w * 0.2;
          catGroup.add(wL);

          const wR = new THREE.Mesh(whiskerGeo, whiskerMat);
          wR.position.set(0.3, 0.175 + w * 0.012, -0.06);
          wR.rotation.z = Math.PI / 2;
          wR.rotation.x = 0.2 - w * 0.2;
          catGroup.add(wR);
        }

        // === TAIL (8-10 small spheres in curved arc) ===
        const tailSegments = [];
        const numTailSegs = 9;
        for (let t = 0; t < numTailSegs; t++) {
          const segSize = 0.022 - t * 0.001;
          const seg = new THREE.Mesh(new THREE.SphereGeometry(Math.max(segSize, 0.01), 6, 4), catMat);
          const progress = t / numTailSegs;
          // Arc: goes back and up
          seg.position.set(
            -0.15 - progress * 0.15,
            0.15 + Math.sin(progress * Math.PI * 0.8) * 0.15,
            0
          );
          seg.name = 'tailSeg' + t;
          tailSegments.push(seg);
          catGroup.add(seg);
        }

        // === LEGS (4 legs with cylinder + sphere paw) ===
        const legPositions = [
          { x: 0.1, z: 0.06, name: 'frontL' },
          { x: 0.1, z: -0.06, name: 'frontR' },
          { x: -0.1, z: 0.06, name: 'backL' },
          { x: -0.1, z: -0.06, name: 'backR' }
        ];
        const legRefs = [];
        legPositions.forEach(lp => {
          const legGroup = new THREE.Group();
          const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.018, 0.1, 8), catMat);
          leg.position.y = -0.05;
          legGroup.add(leg);
          // Paw
          const paw = new THREE.Mesh(new THREE.SphereGeometry(0.022, 6, 4), catMat);
          paw.scale.set(1.0, 0.5, 1.2);
          paw.position.set(0.005, -0.1, 0);
          legGroup.add(paw);
          legGroup.position.set(lp.x, 0.1, lp.z);
          legGroup.name = lp.name;
          legRefs.push(legGroup);
          catGroup.add(legGroup);
        });

        // Position cat on the ground (terrain flattened to y=0.0 near desk)
        catGroup.position.set(
          -2 + i * 2,
          0.0,
          1.5 + Math.random() * 2
        );

        catGroup.userData = {
          speed: 0.006 + Math.random() * 0.008,
          direction: Math.random() * Math.PI * 2,
          walkTimer: 0,
          isWalking: true,
          sitTimer: 0,
          isSitting: false,
          sitDuration: 3 + Math.random() * 4,
          walkDuration: 5 + Math.random() * 5,
          legs: legRefs,
          tailSegments: tailSegments,
          bodyMesh: body
        };

        cats.push(catGroup);
        scene.add(catGroup);
      });
    }

    function createSleepingPerson() {
      // GEOMETRY REFERENCE:
      // Chair: position (0, 0.15, 1.1), seat at global y≈0.50
      // Desk top: y=0.50, thickness 0.08 → surface at y=0.54
      // Desk spans x=-1.5 to 1.5, z=-0.75 to 0.75
      // RULE: anything in desk z-range (z < 0.75) must be y > 0.56
      //        legs/torso body behind desk (z > 0.75) can be any y
      const personGroup = new THREE.Group();
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xF5CBA7, roughness: 0.8 });
      const hoodieMat = new THREE.MeshStandardMaterial({ color: 0x2C3E50, roughness: 0.85 });
      const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.8 });
      const hairMat = new THREE.MeshStandardMaterial({ color: 0x3B2507, roughness: 0.9 });
      const shoeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });

      // All positions are relative to group origin.
      // Group will be at world (0, 0, 0) - NOT offset, direct world coords.

      // === TORSO - stays BEHIND desk edge (z > 0.80) ===
      const torso = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.30, 0.16), hoodieMat);
      torso.position.set(0, 0.82, 0.95); // world z=0.95, behind desk edge 0.75
      torso.rotation.x = -1.1; // Steep forward lean
      torso.name = 'personTorso';
      personGroup.add(torso);

      // Upper back / shoulder hunch behind desk
      const upperBack = new THREE.Mesh(new THREE.SphereGeometry(0.14, 8, 6), hoodieMat);
      upperBack.scale.set(1.0, 0.7, 0.9);
      upperBack.position.set(0, 0.88, 1.02); // behind desk
      personGroup.add(upperBack);

      // === HEAD - on desk surface, y=0.58 (above 0.54 desk surface) ===
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), skinMat);
      head.scale.set(1.0, 0.85, 1.0);
      head.position.set(0, 0.58, 0.35); // on desk, well above surface
      head.name = 'personHead';
      personGroup.add(head);

      // Hair
      const hair = new THREE.Mesh(new THREE.SphereGeometry(0.105, 10, 8), hairMat);
      hair.scale.set(1.0, 0.6, 1.0);
      hair.position.set(0, 0.63, 0.40);
      personGroup.add(hair);

      // Hair fringe
      const fringe = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), hairMat);
      fringe.scale.set(1.5, 0.4, 0.8);
      fringe.position.set(0, 0.62, 0.28);
      personGroup.add(fringe);

      // === ARMS - upper arms bridge from behind desk to desk surface ===
      // Upper arms: center at desk back edge, angled steeply downward-forward
      const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.4, 8), hoodieMat);
      armR.position.set(0.13, 0.65, 0.65); // near desk back edge, y above desk
      armR.rotation.z = 0.25;
      armR.rotation.x = -1.2;
      personGroup.add(armR);

      const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.4, 8), hoodieMat);
      armL.position.set(-0.13, 0.65, 0.65);
      armL.rotation.z = -0.25;
      armL.rotation.x = -1.2;
      personGroup.add(armL);

      // Forearms (on desk surface, forming pillow for head)
      const forearmR = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.22, 8), hoodieMat);
      forearmR.position.set(0.08, 0.57, 0.42); // on desk
      forearmR.rotation.x = -0.15;
      forearmR.rotation.z = 1.2;
      personGroup.add(forearmR);

      const forearmL = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.22, 8), hoodieMat);
      forearmL.position.set(-0.08, 0.57, 0.42);
      forearmL.rotation.x = -0.15;
      forearmL.rotation.z = -1.2;
      personGroup.add(forearmL);

      // Hands
      const handR = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 6), skinMat);
      handR.position.set(0.04, 0.57, 0.32);
      personGroup.add(handR);
      const handL = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 6), skinMat);
      handL.position.set(-0.04, 0.57, 0.32);
      personGroup.add(handL);

      // === LEGS - entirely behind desk (z > 0.75) ===
      // Thighs on chair seat
      const thighR = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.045, 0.3, 8), pantsMat);
      thighR.position.set(0.1, 0.50, 1.08); // at chair
      thighR.rotation.x = -1.45; // nearly horizontal
      personGroup.add(thighR);

      const thighL = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.045, 0.3, 8), pantsMat);
      thighL.position.set(-0.1, 0.50, 1.08);
      thighL.rotation.x = -1.45;
      personGroup.add(thighL);

      // Shins - hanging down from chair
      const shinR = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.035, 0.32, 8), pantsMat);
      shinR.position.set(0.1, 0.25, 0.88);
      shinR.rotation.x = 0.15;
      personGroup.add(shinR);

      const shinL = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.035, 0.32, 8), pantsMat);
      shinL.position.set(-0.1, 0.25, 0.88);
      shinL.rotation.x = 0.15;
      personGroup.add(shinL);

      // Shoes on ground
      const shoeR = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.04, 0.12), shoeMat);
      shoeR.position.set(0.1, 0.05, 0.82);
      personGroup.add(shoeR);
      const shoeL = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.04, 0.12), shoeMat);
      shoeL.position.set(-0.1, 0.05, 0.82);
      personGroup.add(shoeL);

      // Hood bunched at nape of neck
      const hood = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 6), hoodieMat);
      hood.scale.set(1.2, 0.5, 1.0);
      hood.position.set(0, 0.73, 0.55);
      personGroup.add(hood);

      // Group at world origin - all coords are already in world space
      personGroup.position.set(0, 0.0, 0.0);

      personGroup.userData = {
        breathePhase: Math.random() * Math.PI * 2,
        torso: torso,
        head: head,
        upperBack: upperBack
      };

      sleepingPerson = personGroup;
      scene.add(personGroup);
    }

    function createDog() {
      const dogGroup = new THREE.Group();
      const furMat = new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.85 });
      const lightFurMat = new THREE.MeshStandardMaterial({ color: 0xF0D58C, roughness: 0.85 });
      const noseMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
      const eyeHighlight = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const tongueMat = new THREE.MeshStandardMaterial({ color: 0xFF6B8A, roughness: 0.5 });

      // === BODY (multi-sphere, lying down) ===
      // Main body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 10), furMat);
      body.scale.set(1.8, 0.9, 1.0);
      body.position.set(0, 0.16, 0);
      body.name = 'dogBody';
      dogGroup.add(body);

      // Chest (lighter fur)
      const chest = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), lightFurMat);
      chest.scale.set(1.0, 0.85, 0.9);
      chest.position.set(0.18, 0.14, 0);
      dogGroup.add(chest);

      // Rear haunches
      const haunch = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), furMat);
      haunch.scale.set(1.0, 0.85, 1.1);
      haunch.position.set(-0.18, 0.15, 0);
      dogGroup.add(haunch);

      // === HEAD ===
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 10), furMat);
      head.position.set(0.32, 0.24, 0);
      head.name = 'dogHead';
      dogGroup.add(head);

      // Snout
      const snout = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 8), furMat);
      snout.scale.set(1.2, 0.7, 0.8);
      snout.position.set(0.42, 0.2, 0);
      dogGroup.add(snout);

      // Snout underside (lighter)
      const snoutBottom = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), lightFurMat);
      snoutBottom.scale.set(1.0, 0.5, 0.7);
      snoutBottom.position.set(0.4, 0.17, 0);
      dogGroup.add(snoutBottom);

      // Nose
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 6), noseMat);
      nose.position.set(0.49, 0.21, 0);
      dogGroup.add(nose);

      // === EYES ===
      const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 6), eyeMat);
      eyeL.position.set(0.4, 0.28, 0.06);
      dogGroup.add(eyeL);
      const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 6), eyeMat);
      eyeR.position.set(0.4, 0.28, -0.06);
      dogGroup.add(eyeR);

      // Eye highlights
      const hlL = new THREE.Mesh(new THREE.SphereGeometry(0.008, 6, 4), eyeHighlight);
      hlL.position.set(0.415, 0.285, 0.055);
      dogGroup.add(hlL);
      const hlR = new THREE.Mesh(new THREE.SphereGeometry(0.008, 6, 4), eyeHighlight);
      hlR.position.set(0.415, 0.285, -0.055);
      dogGroup.add(hlR);

      // === FLOPPY EARS (drooping down) ===
      const earL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), furMat);
      earL.scale.set(0.6, 1.2, 0.8);
      earL.position.set(0.28, 0.2, 0.12);
      earL.name = 'earL';
      dogGroup.add(earL);

      const earR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), furMat);
      earR.scale.set(0.6, 1.2, 0.8);
      earR.position.set(0.28, 0.2, -0.12);
      earR.name = 'earR';
      dogGroup.add(earR);

      // === TONGUE (small pink piece sticking out) ===
      const tongue = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.015, 0.03), tongueMat);
      tongue.position.set(0.48, 0.16, 0.015);
      tongue.rotation.z = 0.2;
      tongue.name = 'dogTongue';
      dogGroup.add(tongue);

      // === TAIL (chain of spheres, will wag) ===
      const tailSegments = [];
      const numTailSegs = 8;
      for (let t = 0; t < numTailSegs; t++) {
        const segSize = 0.03 - t * 0.002;
        const seg = new THREE.Mesh(new THREE.SphereGeometry(Math.max(segSize, 0.012), 6, 4), furMat);
        const progress = t / numTailSegs;
        seg.position.set(
          -0.28 - progress * 0.18,
          0.18 + Math.sin(progress * Math.PI * 0.6) * 0.12,
          0
        );
        seg.name = 'tailSeg' + t;
        tailSegments.push(seg);
        dogGroup.add(seg);
      }

      // === LEGS (lying down / tucked) ===
      // Front legs - stretched forward
      const frontLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.18, 8), furMat);
      frontLegR.position.set(0.15, 0.06, 0.1);
      frontLegR.rotation.z = Math.PI / 2 - 0.3;
      dogGroup.add(frontLegR);
      const frontLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.18, 8), furMat);
      frontLegL.position.set(0.15, 0.06, -0.1);
      frontLegL.rotation.z = Math.PI / 2 - 0.3;
      dogGroup.add(frontLegL);

      // Front paws
      const pawFR = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), lightFurMat);
      pawFR.scale.set(1.0, 0.5, 1.2);
      pawFR.position.set(0.25, 0.02, 0.1);
      dogGroup.add(pawFR);
      const pawFL = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), lightFurMat);
      pawFL.scale.set(1.0, 0.5, 1.2);
      pawFL.position.set(0.25, 0.02, -0.1);
      dogGroup.add(pawFL);

      // Back legs - tucked under body
      const backLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.15, 8), furMat);
      backLegR.position.set(-0.15, 0.07, 0.12);
      backLegR.rotation.x = -0.3;
      dogGroup.add(backLegR);
      const backLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.15, 8), furMat);
      backLegL.position.set(-0.15, 0.07, -0.12);
      backLegL.rotation.x = 0.3;
      dogGroup.add(backLegL);

      // Back paws
      const pawBR = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), lightFurMat);
      pawBR.scale.set(1.0, 0.5, 1.2);
      pawBR.position.set(-0.2, 0.02, 0.15);
      dogGroup.add(pawBR);
      const pawBL = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), lightFurMat);
      pawBL.scale.set(1.0, 0.5, 1.2);
      pawBL.position.set(-0.2, 0.02, -0.15);
      dogGroup.add(pawBL);

      // Position: lying down near the desk
      dogGroup.position.set(0.8, getTerrainHeight(0.8, 1.5), 1.5);
      dogGroup.rotation.y = -0.8; // Angled toward desk

      dogGroup.userData = {
        tailSegments: tailSegments,
        bodyMesh: body,
        tongue: tongue,
        breathePhase: Math.random() * Math.PI * 2
      };

      dog = dogGroup;
      scene.add(dogGroup);
    }

    function createRabbits() {
      const rabbitConfigs = [
        { color: 0xFFFFFF, x: -2.5, z: 3.2 },
        { color: 0x999999, x: 1.8, z: 4.0 },
        { color: 0xD2B48C, x: -1.0, z: 3.8 }
      ];

      rabbitConfigs.forEach(config => {
        const rabbitGroup = new THREE.Group();
        const furMat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.85 });
        const pinkMat = new THREE.MeshStandardMaterial({ color: 0xFFB6C1, roughness: 0.7 });
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
        const noseMat = new THREE.MeshStandardMaterial({ color: 0xFF9999, roughness: 0.5 });

        // === BODY (round) ===
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), furMat);
        body.scale.set(1.2, 1.0, 1.0);
        body.position.set(0, 0.1, 0);
        body.name = 'rabbitBody';
        rabbitGroup.add(body);

        // === HEAD ===
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 8), furMat);
        head.position.set(0.12, 0.16, 0);
        rabbitGroup.add(head);

        // Cheeks
        const cheekL = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), furMat);
        cheekL.position.set(0.14, 0.13, 0.04);
        rabbitGroup.add(cheekL);
        const cheekR = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), furMat);
        cheekR.position.set(0.14, 0.13, -0.04);
        rabbitGroup.add(cheekR);

        // === EARS (long, upright) ===
        const earL = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.025, 0.12, 6), furMat);
        earL.position.set(0.1, 0.28, 0.025);
        earL.rotation.z = -0.15;
        earL.rotation.x = -0.1;
        rabbitGroup.add(earL);
        const earLInner = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.015, 0.1, 6), pinkMat);
        earLInner.position.set(0.1, 0.28, 0.025);
        earLInner.rotation.z = -0.15;
        earLInner.rotation.x = -0.1;
        rabbitGroup.add(earLInner);

        const earR = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.025, 0.12, 6), furMat);
        earR.position.set(0.1, 0.28, -0.025);
        earR.rotation.z = -0.15;
        earR.rotation.x = 0.1;
        rabbitGroup.add(earR);
        const earRInner = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.015, 0.1, 6), pinkMat);
        earRInner.position.set(0.1, 0.28, -0.025);
        earRInner.rotation.z = -0.15;
        earRInner.rotation.x = 0.1;
        rabbitGroup.add(earRInner);

        // === EYES ===
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 4), eyeMat);
        eyeL.position.set(0.17, 0.18, 0.035);
        rabbitGroup.add(eyeL);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 4), eyeMat);
        eyeR.position.set(0.17, 0.18, -0.035);
        rabbitGroup.add(eyeR);

        // === NOSE ===
        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.008, 6, 4), noseMat);
        nose.position.set(0.19, 0.155, 0);
        rabbitGroup.add(nose);

        // === COTTON TAIL ===
        const tail = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 6), furMat);
        tail.position.set(-0.13, 0.1, 0);
        tail.name = 'rabbitTail';
        rabbitGroup.add(tail);

        // === LEGS ===
        // Front legs (small)
        const frontLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.015, 0.06, 6), furMat);
        frontLegL.position.set(0.06, 0.03, 0.04);
        rabbitGroup.add(frontLegL);
        const frontLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.015, 0.06, 6), furMat);
        frontLegR.position.set(0.06, 0.03, -0.04);
        rabbitGroup.add(frontLegR);

        // Back legs (bigger, for hopping)
        const backLegL = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), furMat);
        backLegL.scale.set(0.8, 1.2, 1.0);
        backLegL.position.set(-0.07, 0.04, 0.05);
        rabbitGroup.add(backLegL);
        const backLegR = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 4), furMat);
        backLegR.scale.set(0.8, 1.2, 1.0);
        backLegR.position.set(-0.07, 0.04, -0.05);
        rabbitGroup.add(backLegR);

        // Position on grass (use terrain height)
        const rabbitGroundY = getTerrainHeight(config.x, config.z);
        rabbitGroup.position.set(config.x, rabbitGroundY, config.z);
        rabbitGroup.rotation.y = Math.random() * Math.PI * 2;

        rabbitGroup.userData = {
          hopTimer: Math.random() * 5,
          hopInterval: 3 + Math.random() * 4,
          isHopping: false,
          hopProgress: 0,
          hopDirection: Math.random() * Math.PI * 2,
          baseY: rabbitGroundY,
          baseX: config.x,
          baseZ: config.z,
          bodyMesh: body
        };

        rabbits.push(rabbitGroup);
        scene.add(rabbitGroup);
      });
    }

    function createSquirrels() {
      const squirrelConfigs = [
        { x: -4.5, z: -3.5 },
        { x: 4.0, z: -4.5 }
      ];

      squirrelConfigs.forEach(config => {
        const squirrelGroup = new THREE.Group();
        const furMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.85 });
        const lightFurMat = new THREE.MeshStandardMaterial({ color: 0xD2691E, roughness: 0.85 });
        const bellyMat = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.85 });
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
        const noseMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });

        // === BODY ===
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 8), furMat);
        body.scale.set(1.3, 1.0, 0.9);
        body.position.set(0, 0.09, 0);
        body.name = 'squirrelBody';
        squirrelGroup.add(body);

        // Belly
        const belly = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), bellyMat);
        belly.scale.set(0.9, 0.8, 0.7);
        belly.position.set(0.03, 0.07, 0);
        squirrelGroup.add(belly);

        // === HEAD ===
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.055, 10, 8), furMat);
        head.position.set(0.1, 0.15, 0);
        squirrelGroup.add(head);

        // Snout
        const snout = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 4), lightFurMat);
        snout.scale.set(1.0, 0.7, 0.7);
        snout.position.set(0.15, 0.13, 0);
        squirrelGroup.add(snout);

        // Nose
        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.008, 6, 4), noseMat);
        nose.position.set(0.175, 0.135, 0);
        squirrelGroup.add(nose);

        // === EARS (small, rounded) ===
        const earL = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 4), furMat);
        earL.scale.set(0.6, 1.0, 0.6);
        earL.position.set(0.08, 0.2, 0.035);
        squirrelGroup.add(earL);
        const earR = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 4), furMat);
        earR.scale.set(0.6, 1.0, 0.6);
        earR.position.set(0.08, 0.2, -0.035);
        squirrelGroup.add(earR);

        // === EYES ===
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 4), eyeMat);
        eyeL.position.set(0.14, 0.165, 0.03);
        squirrelGroup.add(eyeL);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 4), eyeMat);
        eyeR.position.set(0.14, 0.165, -0.03);
        squirrelGroup.add(eyeR);

        // === BIG BUSHY TAIL (curved upward, chain of spheres) ===
        const tailSegments = [];
        const numTailSegs = 10;
        for (let t = 0; t < numTailSegs; t++) {
          const progress = t / numTailSegs;
          const segSize = 0.02 + Math.sin(progress * Math.PI) * 0.03; // Gets fatter in middle
          const seg = new THREE.Mesh(new THREE.SphereGeometry(segSize, 6, 4), lightFurMat);
          seg.position.set(
            -0.08 - progress * 0.08,
            0.1 + progress * 0.2 + Math.sin(progress * Math.PI) * 0.05,
            0
          );
          seg.name = 'tailSeg' + t;
          tailSegments.push(seg);
          squirrelGroup.add(seg);
        }

        // === LEGS ===
        // Front legs
        const frontLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.01, 0.06, 6), furMat);
        frontLegL.position.set(0.05, 0.03, 0.035);
        squirrelGroup.add(frontLegL);
        const frontLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.01, 0.06, 6), furMat);
        frontLegR.position.set(0.05, 0.03, -0.035);
        squirrelGroup.add(frontLegR);

        // Back legs (larger)
        const backLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.012, 0.07, 6), furMat);
        backLegL.position.set(-0.05, 0.03, 0.04);
        squirrelGroup.add(backLegL);
        const backLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.012, 0.07, 6), furMat);
        backLegR.position.set(-0.05, 0.03, -0.04);
        squirrelGroup.add(backLegR);

        // Position near trees (use terrain height)
        const sqGroundY = getTerrainHeight(config.x, config.z);
        squirrelGroup.position.set(config.x, sqGroundY, config.z);
        squirrelGroup.rotation.y = Math.random() * Math.PI * 2;

        squirrelGroup.userData = {
          tailSegments: tailSegments,
          bodyMesh: body,
          scurryTimer: Math.random() * 6,
          scurryInterval: 4 + Math.random() * 5,
          isScurrying: false,
          scurryProgress: 0,
          scurryDirection: Math.random() * Math.PI * 2,
          scurryDistance: 0.5 + Math.random() * 0.5,
          startX: config.x,
          startZ: config.z,
          groundY: sqGroundY
        };

        squirrels.push(squirrelGroup);
        scene.add(squirrelGroup);
      });
    }

    function createBirds() {
      const birdColors = [0x333333, 0x333333, 0x4488CC, 0x333333, 0x4488CC, 0x333333, 0x4488CC, 0x333333, 0x4488CC, 0x333333];

      for (let i = 0; i < 10; i++) {
        const birdGroup = new THREE.Group();
        const color = birdColors[i];
        const birdMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
        const beakMat = new THREE.MeshStandardMaterial({ color: 0xFF8800, roughness: 0.5 });

        // Body
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 6), birdMat);
        body.scale.set(1.3, 0.8, 0.8);
        birdGroup.add(body);

        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 6), birdMat);
        head.position.set(0.035, 0.015, 0);
        birdGroup.add(head);

        // Beak
        const beak = new THREE.Mesh(new THREE.ConeGeometry(0.006, 0.02, 4), beakMat);
        beak.rotation.z = -Math.PI / 2;
        beak.position.set(0.055, 0.012, 0);
        birdGroup.add(beak);

        // Wings (ShapeGeometry triangles)
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(-0.03, 0.04);
        wingShape.lineTo(-0.06, 0.01);
        wingShape.lineTo(0, 0);
        const wingGeo = new THREE.ShapeGeometry(wingShape);
        const wingMat = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide, roughness: 0.6 });

        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-0.005, 0.01, 0.015);
        leftWing.rotation.y = Math.PI / 2;
        leftWing.name = 'leftWing';
        birdGroup.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.position.set(-0.005, 0.01, -0.015);
        rightWing.rotation.y = -Math.PI / 2;
        rightWing.scale.x = -1;
        rightWing.name = 'rightWing';
        birdGroup.add(rightWing);

        // Tail feathers
        const tailShape = new THREE.Shape();
        tailShape.moveTo(0, 0);
        tailShape.lineTo(-0.025, 0.008);
        tailShape.lineTo(-0.03, -0.005);
        tailShape.lineTo(0, 0);
        const tailGeo = new THREE.ShapeGeometry(tailShape);
        const tail = new THREE.Mesh(tailGeo, wingMat);
        tail.position.set(-0.035, 0.005, 0);
        birdGroup.add(tail);

        // Eye (tiny white dot)
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.004, 4, 4), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        eye.position.set(0.045, 0.022, 0.012);
        birdGroup.add(eye);

        // Assign to one of 2 flocks
        const flock = i < 5 ? 0 : 1;
        const flockCenterX = flock === 0 ? -3 : 4;
        const flockCenterZ = flock === 0 ? -4 : -6;
        const flockY = flock === 0 ? 5 : 6.5;

        birdGroup.position.set(
          flockCenterX + (Math.random() - 0.5) * 2,
          flockY + Math.random() * 1.5,
          flockCenterZ + (Math.random() - 0.5) * 2
        );

        birdGroup.userData = {
          flock: flock,
          flockCenterX: flockCenterX,
          flockCenterZ: flockCenterZ,
          flockY: flockY,
          phase: Math.random() * Math.PI * 2,
          radius: 1.5 + Math.random() * 1.5,
          speed: 0.3 + Math.random() * 0.2,
          wingSpeed: 8 + Math.random() * 4,
          swoopTimer: Math.random() * 20,
          isSwooping: false,
          swoopProgress: 0
        };

        birds.push(birdGroup);
        scene.add(birdGroup);
      }
    }

    function createTrees() {
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D3A1A, roughness: 0.9 });
      const leafColors = [0x2E7D32, 0x388E3C, 0x43A047, 0x2E7D32, 0x388E3C];

      const treeConfigs = [
        { x: -5, z: -4, trunkH: 1.0, canopyR: 0.6, scale: 1.0 },
        { x: -3.5, z: -6, trunkH: 0.7, canopyR: 0.45, scale: 0.8 },
        { x: 4.5, z: -5, trunkH: 1.2, canopyR: 0.7, scale: 1.1 },
        { x: 3, z: -7, trunkH: 0.8, canopyR: 0.5, scale: 0.9 },
        { x: -1, z: -6.5, trunkH: 1.1, canopyR: 0.65, scale: 1.0 },
        { x: 6, z: -3.5, trunkH: 0.6, canopyR: 0.4, scale: 0.7 },
        { x: -6, z: -7, trunkH: 0.9, canopyR: 0.55, scale: 0.95 }
      ];

      treeConfigs.forEach(tc => {
        const treeGroup = new THREE.Group();
        const canopySpheres = [];

        // Trunk
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * tc.scale, 0.1 * tc.scale, tc.trunkH, 8),
          trunkMat
        );
        trunk.position.y = tc.trunkH / 2 - 0.5;
        trunk.castShadow = true;
        treeGroup.add(trunk);

        // Canopy: cluster of 4-6 overlapping green spheres
        const numPuffs = 4 + Math.floor(Math.random() * 3);
        for (let j = 0; j < numPuffs; j++) {
          const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
          const leafMat = new THREE.MeshStandardMaterial({ color: leafColor, roughness: 0.85 });
          const puffSize = (tc.canopyR * 0.5 + Math.random() * tc.canopyR * 0.4) * tc.scale;
          const puff = new THREE.Mesh(new THREE.SphereGeometry(puffSize, 10, 8), leafMat);
          puff.position.set(
            (Math.random() - 0.5) * tc.canopyR * tc.scale * 0.8,
            tc.trunkH - 0.5 + tc.canopyR * tc.scale * 0.3 + Math.random() * tc.canopyR * tc.scale * 0.5,
            (Math.random() - 0.5) * tc.canopyR * tc.scale * 0.8
          );
          puff.castShadow = true;
          puff.userData.origX = puff.position.x;
          puff.userData.origZ = puff.position.z;
          canopySpheres.push(puff);
          treeGroup.add(puff);
        }

        treeGroup.position.set(tc.x, 0, tc.z);
        treeGroup.userData = {
          canopySpheres: canopySpheres,
          swayPhase: Math.random() * Math.PI * 2,
          swaySpeed: 0.5 + Math.random() * 0.5,
          swayAmount: 0.02 + Math.random() * 0.02
        };

        trees.push(treeGroup);
        scene.add(treeGroup);
      });
    }

    function createRocks() {
      const rockColors = [0x666666, 0x888888, 0x777777, 0x5a5a5a, 0x999999];

      const rockConfigs = [
        // Near desk
        { x: 1.8, z: 0.5, s: 0.08 }, { x: -1.8, z: 0.8, s: 0.06 },
        { x: 2.2, z: -0.3, s: 0.12 },
        // Scattered in field
        { x: 3, z: 2, s: 0.15 }, { x: -3.5, z: 1.5, s: 0.2 },
        { x: 4, z: -2, s: 0.1 }, { x: -2, z: 3, s: 0.07 },
        { x: 1, z: 3.5, s: 0.05 }, { x: -4, z: -1, s: 0.18 },
        { x: 5, z: 1, s: 0.04 }, { x: -1, z: 4, s: 0.03 },
        { x: 3.5, z: -4.5, s: 0.14 }, { x: -5.5, z: -2, s: 0.09 },
        { x: 0.5, z: 5, s: 0.06 }, { x: -3, z: -3, s: 0.11 }
      ];

      rockConfigs.forEach(rc => {
        const color = rockColors[Math.floor(Math.random() * rockColors.length)];
        const rockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 + Math.random() * 0.2, metalness: 0.05 });

        // Use dodecahedron or icosahedron randomly for variety
        const geo = Math.random() > 0.5
          ? new THREE.DodecahedronGeometry(rc.s, 0)
          : new THREE.IcosahedronGeometry(rc.s, 0);

        // Displace vertices slightly for organic look
        const positions = geo.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i] += (Math.random() - 0.5) * rc.s * 0.3;
          positions[i + 1] += (Math.random() - 0.5) * rc.s * 0.25;
          positions[i + 2] += (Math.random() - 0.5) * rc.s * 0.3;
        }
        geo.computeVertexNormals();

        const rock = new THREE.Mesh(geo, rockMat);
        rock.position.set(rc.x, -0.45 + rc.s * 0.3, rc.z);
        rock.rotation.set(Math.random() * 0.5, Math.random() * Math.PI, Math.random() * 0.5);
        rock.scale.y = 0.6 + Math.random() * 0.4; // Flatten some
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
      });
    }

    function createPond() {
      // Circular reflective pond
      pondGeometry = new THREE.CircleGeometry(1.5, 48);
      const pondMat = new THREE.MeshStandardMaterial({
        color: 0x2288AA,
        transparent: true,
        opacity: 0.7,
        metalness: 0.9,
        roughness: 0.1,
        side: THREE.DoubleSide
      });
      pond = new THREE.Mesh(pondGeometry, pondMat);
      pond.rotation.x = -Math.PI / 2;
      pond.position.set(4, -0.48, -3);
      pond.receiveShadow = true;
      scene.add(pond);

      // Store original vertex positions for ripple animation
      const posArray = pondGeometry.attributes.position.array;
      pond.userData.originalPositions = new Float32Array(posArray.length);
      for (let i = 0; i < posArray.length; i++) {
        pond.userData.originalPositions[i] = posArray[i];
      }

      // Lily pads
      const lilyMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8, side: THREE.DoubleSide });
      const lilyPositions = [
        { x: 4.3, z: -3.2, r: 0.15 },
        { x: 3.6, z: -2.6, r: 0.12 },
        { x: 4.7, z: -2.8, r: 0.1 },
        { x: 3.9, z: -3.6, r: 0.13 }
      ];
      lilyPositions.forEach(lp => {
        const lily = new THREE.Mesh(new THREE.CircleGeometry(lp.r, 12), lilyMat);
        lily.rotation.x = -Math.PI / 2;
        lily.position.set(lp.x, -0.46, lp.z);
        scene.add(lily);

        // Small pink flower on some lily pads
        if (Math.random() > 0.5) {
          const flowerMat = new THREE.MeshStandardMaterial({ color: 0xFF69B4, roughness: 0.6 });
          for (let p = 0; p < 5; p++) {
            const petal = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 4), flowerMat);
            const angle = (p / 5) * Math.PI * 2;
            petal.position.set(lp.x + Math.cos(angle) * 0.025, -0.43, lp.z + Math.sin(angle) * 0.025);
            petal.scale.y = 0.4;
            scene.add(petal);
          }
          const center = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 4), new THREE.MeshStandardMaterial({ color: 0xFFEB3B }));
          center.position.set(lp.x, -0.42, lp.z);
          scene.add(center);
        }
      });

      // Edge rocks around pond
      const edgeRockMat = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.85 });
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
        const dist = 1.45 + Math.random() * 0.2;
        const rockSize = 0.06 + Math.random() * 0.08;
        const geo = new THREE.DodecahedronGeometry(rockSize, 0);
        const rock = new THREE.Mesh(geo, edgeRockMat);
        rock.position.set(
          4 + Math.cos(angle) * dist,
          -0.48 + rockSize * 0.3,
          -3 + Math.sin(angle) * dist
        );
        rock.rotation.set(Math.random(), Math.random(), Math.random());
        rock.scale.y = 0.6;
        scene.add(rock);
      }
    }

    function createFallingLeaves() {
      const leafColors = [0x4CAF50, 0x8BC34A, 0xFF9800, 0xFFC107, 0xF44336, 0x66BB6A];

      for (let i = 0; i < 18; i++) {
        const color = leafColors[Math.floor(Math.random() * leafColors.length)];
        const leafMat = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide, roughness: 0.8 });
        const leaf = new THREE.Mesh(new THREE.PlaneGeometry(0.025, 0.018), leafMat);

        leaf.position.set(
          (Math.random() - 0.5) * 12,
          2 + Math.random() * 6,
          (Math.random() - 0.5) * 12
        );

        leaf.userData = {
          fallSpeed: 0.003 + Math.random() * 0.004,
          swaySpeed: 1 + Math.random() * 2,
          swayAmount: 0.3 + Math.random() * 0.5,
          spinSpeed: 1 + Math.random() * 3,
          phase: Math.random() * Math.PI * 2,
          startX: leaf.position.x,
          startZ: leaf.position.z
        };

        fallingLeaves.push(leaf);
        scene.add(leaf);
      }
    }

    function createDesk() {
      // Procedural wood grain texture
      const woodCanvas = document.createElement('canvas');
      woodCanvas.width = 256; woodCanvas.height = 256;
      const wCtx = woodCanvas.getContext('2d');
      wCtx.fillStyle = '#5C4033';
      wCtx.fillRect(0, 0, 256, 256);
      // Add wood grain lines
      for (let i = 0; i < 40; i++) {
        wCtx.strokeStyle = `rgba(80, 50, 30, ${0.1 + Math.random() * 0.15})`;
        wCtx.lineWidth = 1 + Math.random() * 2;
        wCtx.beginPath();
        const y = i * 6 + Math.random() * 4;
        wCtx.moveTo(0, y);
        wCtx.bezierCurveTo(64, y + Math.random()*4, 192, y - Math.random()*4, 256, y + Math.random()*3);
        wCtx.stroke();
      }
      const woodTexture = new THREE.CanvasTexture(woodCanvas);

      const deskMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0x5C4033,
        roughness: 0.7
      });

      // Desk top
      const deskTopGeometry = new THREE.BoxGeometry(3, 0.08, 1.5);
      const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
      deskTop.position.set(0, 0.5, 0);
      deskTop.castShadow = true;
      deskTop.receiveShadow = true;
      scene.add(deskTop);

      // Desk legs
      const legGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
      [[-1.4, 0, -0.65], [1.4, 0, -0.65], [-1.4, 0, 0.65], [1.4, 0, 0.65]].forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, deskMaterial);
        leg.position.set(...pos);
        leg.castShadow = true;
        scene.add(leg);
      });
    }

    function createMonitor() {
      // Classic CRT monitor - improved quality
      const monitorColor = 0xD4C5A9; // Beige/off-white classic color
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: monitorColor, roughness: 0.6, metalness: 0.05 });
      const darkPlastic = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });

      // Main monitor body (CRT bulk with beveled appearance)
      const monitorGroup = new THREE.Group();

      // Main body
      const bodyGeometry = new THREE.BoxGeometry(1.15, 0.95, 0.95);
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0, 0);
      body.castShadow = true;
      monitorGroup.add(body);

      // Front face panel (slightly inset)
      const frontPanel = new THREE.Mesh(
        new THREE.BoxGeometry(1.1, 0.9, 0.05),
        bodyMaterial
      );
      frontPanel.position.set(0, 0.02, 0.48);
      monitorGroup.add(frontPanel);

      // Screen bezel (dark frame around screen)
      const bezelOuter = new THREE.Mesh(
        new THREE.BoxGeometry(0.95, 0.75, 0.03),
        darkPlastic
      );
      bezelOuter.position.set(0, 0.05, 0.52);
      monitorGroup.add(bezelOuter);

      // Inner bezel lip (slight depth)
      const bezelInner = new THREE.Mesh(
        new THREE.BoxGeometry(0.88, 0.68, 0.02),
        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 })
      );
      bezelInner.position.set(0, 0.05, 0.535);
      monitorGroup.add(bezelInner);

      // Ventilation slots on sides
      const ventMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 });
      for (let i = 0; i < 6; i++) {
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.08, 0.4), ventMat);
        vent.position.set(0.58, 0.25 - i * 0.1, 0);
        monitorGroup.add(vent);
        const vent2 = vent.clone();
        vent2.position.x = -0.58;
        monitorGroup.add(vent2);
      }

      // Bottom control panel area
      const controlPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.08, 0.05),
        new THREE.MeshStandardMaterial({ color: 0xc0b8a0, roughness: 0.5 })
      );
      controlPanel.position.set(0, -0.35, 0.52);
      monitorGroup.add(controlPanel);

      // Control buttons
      const buttonMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.3 });
      for (let i = 0; i < 4; i++) {
        const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.02, 8), buttonMat);
        btn.rotation.x = Math.PI / 2;
        btn.position.set(-0.15 + i * 0.08, -0.35, 0.54);
        monitorGroup.add(btn);
      }

      // Power LED
      const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
      const led = new THREE.Mesh(new THREE.CircleGeometry(0.012, 12), ledMaterial);
      led.position.set(0.22, -0.35, 0.545);
      monitorGroup.add(led);

      // Brand logo area (subtle indent)
      const logoArea = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.025, 0.01),
        new THREE.MeshStandardMaterial({ color: 0xb8b0a0, roughness: 0.3 })
      );
      logoArea.position.set(0, -0.42, 0.52);
      monitorGroup.add(logoArea);

      monitorGroup.position.set(0, 1.1, -0.18);
      scene.add(monitorGroup);

      // === SCREEN - Clean XP Bliss display ===
      const screenGeometry = new THREE.PlaneGeometry(0.82, 0.62, 1, 1);

      // Create clean XP desktop texture (no vignette to avoid moiré)
      const canvas = document.createElement('canvas');
      canvas.width = 820;  // Match aspect ratio to geometry to avoid stretching
      canvas.height = 620;
      const ctx = canvas.getContext('2d');

      // XP Bliss background - authentic colors
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1E5BC6');    // Deep blue
      gradient.addColorStop(0.3, '#3A7BD5');
      gradient.addColorStop(0.6, '#5A9BD5');
      gradient.addColorStop(1, '#8ECAE6');    // Light blue at horizon
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Rolling hills - multiple layers for depth
      // Back hill
      ctx.fillStyle = '#2D8F38';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(160, 350, 320, 270, 480, 330);
      ctx.bezierCurveTo(640, 390, 720, 300, 820, 360);
      ctx.lineTo(820, canvas.height);
      ctx.fill();

      // Middle hill
      ctx.fillStyle = '#3CB043';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(120, 380, 280, 320, 410, 380);
      ctx.bezierCurveTo(560, 440, 680, 340, 820, 400);
      ctx.lineTo(820, canvas.height);
      ctx.fill();

      // Front hill - brightest
      ctx.fillStyle = '#4ADE54';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(205, 470, 410, 420, 615, 470);
      ctx.bezierCurveTo(720, 500, 780, 450, 820, canvas.height - 80);
      ctx.lineTo(820, canvas.height);
      ctx.fill();

      // Fluffy clouds - drawn with solid fills
      ctx.fillStyle = '#ffffff';
      const cloudPositions = [
        [100, 80, 36], [220, 110, 44], [360, 72, 40],
        [500, 100, 38], [620, 80, 42], [740, 120, 36]
      ];
      cloudPositions.forEach(([x, y, r]) => {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.arc(x + r*0.6, y - r*0.35, r*0.75, 0, Math.PI * 2);
        ctx.arc(x + r*1.1, y - r*0.1, r*0.85, 0, Math.PI * 2);
        ctx.arc(x + r*1.5, y + r*0.1, r*0.7, 0, Math.PI * 2);
        ctx.arc(x + r*0.3, y + r*0.25, r*0.6, 0, Math.PI * 2);
        ctx.fill();
      });

      // Desktop icons (simplified, no shadows that cause artifacts)
      const icons = [
        { name: 'My Computer', y: 40 },
        { name: 'Recycle Bin', y: 105 },
        { name: 'My Documents', y: 170 }
      ];
      icons.forEach(icon => {
        // Icon box
        ctx.fillStyle = '#e0e8f0';
        ctx.fillRect(24, icon.y, 38, 38);
        // Icon text
        ctx.fillStyle = '#ffffff';
        ctx.font = '9px Tahoma, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(icon.name, 43, icon.y + 52);
      });
      ctx.textAlign = 'left';

      // Taskbar - solid colors
      ctx.fillStyle = '#245ED8';
      ctx.fillRect(0, canvas.height - 32, canvas.width, 32);

      // Taskbar top edge highlight
      ctx.fillStyle = '#3168DC';
      ctx.fillRect(0, canvas.height - 32, canvas.width, 3);

      // Start button
      ctx.fillStyle = '#2D8F2D';
      ctx.fillRect(2, canvas.height - 30, 80, 26);

      // Start button highlight
      ctx.fillStyle = '#3C9C3C';
      ctx.fillRect(2, canvas.height - 30, 80, 2);

      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold italic 13px Tahoma, sans-serif';
      ctx.fillText('start', 28, canvas.height - 13);

      // Clock in system tray
      ctx.fillStyle = '#ffffff';
      ctx.font = '9px Tahoma, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText('4:20 PM', canvas.width - 8, canvas.height - 12);

      // Create texture with settings to prevent moiré/aliasing
      const screenTexture = new THREE.CanvasTexture(canvas);
      screenTexture.minFilter = THREE.LinearFilter;
      screenTexture.magFilter = THREE.LinearFilter;
      screenTexture.generateMipmaps = false; // Disable mipmaps to prevent artifacts

      const screenMaterial = new THREE.MeshBasicMaterial({
        map: screenTexture
      });

      screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
      screenMesh.position.set(0, 1.15, 0.37);
      screenMesh.name = 'screen';
      scene.add(screenMesh);

      // Monitor stand (neck)
      const standNeck = new THREE.Mesh(
        new THREE.BoxGeometry(0.35, 0.12, 0.45),
        bodyMaterial
      );
      standNeck.position.set(0, 0.58, -0.15);
      standNeck.castShadow = true;
      scene.add(standNeck);

      // Monitor base (wider foot)
      const baseGeometry = new THREE.BoxGeometry(0.55, 0.04, 0.35);
      const base = new THREE.Mesh(baseGeometry, bodyMaterial);
      base.position.set(0, 0.52, -0.08);
      base.castShadow = true;
      scene.add(base);

      // Tilt adjustment mechanism
      const tiltMech = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.06, 0.02, 16),
        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.3 })
      );
      tiltMech.rotation.x = Math.PI / 2;
      tiltMech.position.set(0, 0.64, -0.2);
      scene.add(tiltMech);
    }

    function createKeyboard() {
      const kbMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });
      const keyMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4 });

      const kbGeometry = new THREE.BoxGeometry(0.6, 0.03, 0.2);
      const kb = new THREE.Mesh(kbGeometry, kbMaterial);
      kb.position.set(0, 0.56, 0.45);
      kb.castShadow = true;
      scene.add(kb);

      // Keys
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 12; col++) {
          const keyGeometry = new THREE.BoxGeometry(0.04, 0.015, 0.04);
          const key = new THREE.Mesh(keyGeometry, keyMaterial);
          key.position.set(-0.25 + col * 0.045, 0.58, 0.38 + row * 0.045);
          scene.add(key);
        }
      }
    }

    function createMouse() {
      const mouseMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });

      const mouseGeometry = new THREE.SphereGeometry(0.04, 12, 8);
      const mouseMeshObj = new THREE.Mesh(mouseGeometry, mouseMaterial);
      mouseMeshObj.scale.set(0.8, 0.3, 1.2);
      mouseMeshObj.position.set(0.5, 0.55, 0.45);
      mouseMeshObj.castShadow = true;
      scene.add(mouseMeshObj);

      // Cable
      const cableGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8);
      const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const cable = new THREE.Mesh(cableGeometry, cableMaterial);
      cable.position.set(0.5, 0.54, 0.25);
      cable.rotation.x = Math.PI / 2;
      scene.add(cable);
    }

    function createDecorations() {
      // Plant
      const potMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const potGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 8);
      const pot = new THREE.Mesh(potGeometry, potMaterial);
      pot.position.set(-1.2, 0.62, 0);
      pot.castShadow = true;
      scene.add(pot);

      const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
      for (let i = 0; i < 5; i++) {
        const leafGeometry = new THREE.ConeGeometry(0.03, 0.2, 4);
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(-1.2 + Math.cos(angle) * 0.05, 0.8, Math.sin(angle) * 0.05);
        leaf.rotation.x = 0.3 * Math.cos(angle);
        leaf.rotation.z = 0.3 * Math.sin(angle);
        scene.add(leaf);
      }

      // Coffee mug (rounder with handle)
      const mugMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3 });
      const mugGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.1, 24);
      const mug = new THREE.Mesh(mugGeometry, mugMaterial);
      mug.position.set(1.1, 0.59, 0.3);
      mug.castShadow = true;
      scene.add(mug);

      // Mug handle (torus)
      const handle = new THREE.Mesh(
        new THREE.TorusGeometry(0.025, 0.006, 8, 12, Math.PI),
        mugMaterial
      );
      handle.rotation.y = Math.PI / 2;
      handle.position.set(1.15, 0.59, 0.3);
      scene.add(handle);

      const coffeeGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 24);
      const coffeeMaterial = new THREE.MeshStandardMaterial({ color: 0x3C1810, roughness: 0.2 });
      const coffee = new THREE.Mesh(coffeeGeometry, coffeeMaterial);
      coffee.position.set(1.1, 0.63, 0.3);
      scene.add(coffee);

      // Steam particles above coffee
      const steamMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
      for (let i = 0; i < 8; i++) {
        const steam = new THREE.Mesh(new THREE.SphereGeometry(0.008, 6, 6), steamMat.clone());
        steam.position.set(1.1 + (Math.random()-0.5)*0.03, 0.65 + Math.random()*0.1, 0.3 + (Math.random()-0.5)*0.03);
        steam.userData = { baseY: steam.position.y, phase: Math.random() * Math.PI * 2, speed: 0.3 + Math.random() * 0.3 };
        steamParticles.push(steam);
        scene.add(steam);
      }

      // Add workspace details (gaming chair, headphones, energy drinks, etc.)
      createWorkspaceDetails();
    }

    function createWorkspaceDetails() {
      // Developer workspace accessories that look great in low-poly style

      // === GAMING CHAIR (empty, slightly pushed back) ===
      const chairGroup = new THREE.Group();
      const chairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2, metalness: 0.1 });
      const chairRed = new THREE.MeshStandardMaterial({ color: 0xff2222, roughness: 0.3 }); // Vibrant red accent
      const metalMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.2 });

      // Seat cushion
      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.08, 0.45), chairMat);
      seat.position.y = 0.35;
      chairGroup.add(seat);

      // Seat side bolsters
      const seatBolster = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.4), chairRed);
      seatBolster.position.set(-0.22, 0.38, 0);
      chairGroup.add(seatBolster);
      const seatBolster2 = seatBolster.clone();
      seatBolster2.position.x = 0.22;
      chairGroup.add(seatBolster2);

      // Back rest
      const backRest = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.55, 0.08), chairMat);
      backRest.position.set(0, 0.65, -0.22);
      backRest.rotation.x = 0.1;
      chairGroup.add(backRest);

      // Back bolsters (racing style)
      const backBolster = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.45, 0.1), chairRed);
      backBolster.position.set(-0.2, 0.62, -0.2);
      backBolster.rotation.x = 0.1;
      chairGroup.add(backBolster);
      const backBolster2 = backBolster.clone();
      backBolster2.position.x = 0.2;
      chairGroup.add(backBolster2);

      // Headrest
      const headrest = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.12, 0.08), chairMat);
      headrest.position.set(0, 0.98, -0.22);
      chairGroup.add(headrest);

      // Armrests
      const armrestBase = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.15, 0.04), metalMat);
      armrestBase.position.set(-0.28, 0.42, 0.05);
      chairGroup.add(armrestBase);
      const armrestTop = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.2), chairMat);
      armrestTop.position.set(-0.28, 0.5, 0.05);
      chairGroup.add(armrestTop);
      const armrestBase2 = armrestBase.clone();
      armrestBase2.position.x = 0.28;
      chairGroup.add(armrestBase2);
      const armrestTop2 = armrestTop.clone();
      armrestTop2.position.x = 0.28;
      chairGroup.add(armrestTop2);

      // Gas cylinder
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.25, 12), metalMat);
      cylinder.position.set(0, 0.15, 0);
      chairGroup.add(cylinder);

      // 5-star base
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.025, 0.28), metalMat);
        arm.position.set(Math.sin(angle) * 0.14, 0.02, Math.cos(angle) * 0.14);
        arm.rotation.y = angle;
        chairGroup.add(arm);

        // Wheel
        const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.04, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(Math.sin(angle) * 0.28, 0.02, Math.cos(angle) * 0.28);
        chairGroup.add(wheel);
      }

      chairGroup.position.set(0, 0.15, 1.1); // Pushed back from desk, raised well above terrain
      chairGroup.rotation.y = 0.15; // Slightly angled
      scene.add(chairGroup);

      // === HEADPHONES on desk ===
      const headphonesMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });
      const headphonesAccent = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.4 }); // RGB accent

      const hpGroup = new THREE.Group();
      // Headband
      const headband = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.012, 8, 16, Math.PI), headphonesMat);
      headband.rotation.x = Math.PI / 2;
      headband.position.y = 0.04;
      hpGroup.add(headband);

      // Ear cups
      const earCup = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.03, 12), headphonesMat);
      earCup.rotation.z = Math.PI / 2;
      earCup.position.set(-0.08, 0, 0);
      hpGroup.add(earCup);
      const earCup2 = earCup.clone();
      earCup2.position.x = 0.08;
      hpGroup.add(earCup2);

      // RGB ring on cups
      const rgbRing = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 8, 16), headphonesAccent);
      rgbRing.rotation.y = Math.PI / 2;
      rgbRing.position.set(-0.095, 0, 0);
      hpGroup.add(rgbRing);
      const rgbRing2 = rgbRing.clone();
      rgbRing2.position.x = 0.095;
      hpGroup.add(rgbRing2);

      hpGroup.position.set(0.7, 0.65, 0.2);
      hpGroup.rotation.y = -0.5;
      hpGroup.rotation.x = Math.PI / 2; // Laying flat
      scene.add(hpGroup);

      // === ENERGY DRINK CANS ===
      const canMat1 = new THREE.MeshStandardMaterial({ color: 0x00ff88, metalness: 0.6, roughness: 0.15 }); // Monster green
      const canMat2 = new THREE.MeshStandardMaterial({ color: 0x0066ff, metalness: 0.6, roughness: 0.15 }); // Blue
      const canTop = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.15 });

      // Can 1 (standing)
      const can1 = new THREE.Group();
      const canBody1 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.1, 12), canMat1);
      can1.add(canBody1);
      const canTop1 = new THREE.Mesh(new THREE.CylinderGeometry(0.023, 0.025, 0.01, 12), canTop);
      canTop1.position.y = 0.05;
      can1.add(canTop1);
      can1.position.set(-0.85, 0.59, 0.35);
      scene.add(can1);

      // Can 2 (tipped over, empty)
      const can2 = new THREE.Group();
      const canBody2 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.1, 12), canMat2);
      can2.add(canBody2);
      const canTop2 = new THREE.Mesh(new THREE.CylinderGeometry(0.023, 0.025, 0.01, 12), canTop);
      canTop2.position.y = 0.05;
      can2.add(canTop2);
      can2.position.set(-0.75, 0.555, 0.45);
      can2.rotation.z = Math.PI / 2;
      can2.rotation.y = 0.3;
      scene.add(can2);

      // === STICKY NOTES ===
      const stickyYellow = new THREE.MeshStandardMaterial({ color: 0xffee55, roughness: 0.9 });
      const stickyPink = new THREE.MeshStandardMaterial({ color: 0xff88aa, roughness: 0.9 });
      const stickyBlue = new THREE.MeshStandardMaterial({ color: 0x55ccff, roughness: 0.9 });

      // Sticky note stack
      const sticky1 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.005, 0.12), stickyYellow);
      sticky1.position.set(-1.0, 0.555, -0.2);
      sticky1.rotation.y = 0.1;
      scene.add(sticky1);

      const sticky2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.003, 0.1), stickyPink);
      sticky2.position.set(-1.0, 0.56, -0.18);
      sticky2.rotation.y = -0.15;
      scene.add(sticky2);

      // Sticky on monitor
      const stickyOnMonitor = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.002), stickyBlue);
      stickyOnMonitor.position.set(0.52, 1.35, 0.31);
      stickyOnMonitor.rotation.y = -0.05;
      scene.add(stickyOnMonitor);

      // === BOOKS/NOTEBOOKS ===
      const bookMat1 = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.8 });
      const bookMat2 = new THREE.MeshStandardMaterial({ color: 0x882244, roughness: 0.8 });
      const pageMat = new THREE.MeshStandardMaterial({ color: 0xffffee, roughness: 0.9 });

      // Book stack
      const book1 = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.03, 0.25), bookMat1);
      book1.position.set(1.2, 0.555, -0.1);
      scene.add(book1);

      const book2 = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.025, 0.22), bookMat2);
      book2.position.set(1.2, 0.58, -0.1);
      book2.rotation.y = 0.15;
      scene.add(book2);

      // === PHONE on desk ===
      const phoneMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 });
      const phoneScreen = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1 });

      const phone = new THREE.Group();
      const phoneBody = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.008, 0.09), phoneMat);
      phone.add(phoneBody);
      const phoneScreenMesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.002, 0.08), phoneScreen);
      phoneScreenMesh.position.y = 0.005;
      phone.add(phoneScreenMesh);
      phone.position.set(0.35, 0.555, 0.5);
      phone.rotation.y = 0.8;
      scene.add(phone);

      // === USB/CABLE mess ===
      const cableMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });

      // Coiled cable
      for (let i = 0; i < 8; i++) {
        const segment = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.006, 0.04, 6), cableMat);
        segment.position.set(
          -0.6 + Math.sin(i * 0.8) * 0.03,
          0.54,
          0.55 + i * 0.015
        );
        segment.rotation.z = Math.PI / 2;
        segment.rotation.y = i * 0.3;
        scene.add(segment);
      }
    }

    // Mouse move - check if hovering screen
    function onMouseMove(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      const hint = document.getElementById('click-hint');
      if (intersects.length > 0) {
        hint.classList.add('visible');
        document.body.style.cursor = 'pointer';
      } else {
        hint.classList.remove('visible');
        document.body.style.cursor = 'grab';
      }
    }

    // Click - zoom into screen
    function onMouseClick(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      if (intersects.length > 0) {
        zoomIntoScreen();
      }
    }

    // Smooth zoom animation into screen
    function zoomIntoScreen() {
      isZooming = true;
      controls.enabled = false;
      playEnterSound(); // Play enter sound
      maybeStartHiss(); // Start background hiss

      // Hide UI
      document.getElementById('click-hint').classList.remove('visible');
      document.getElementById('controls-hint').classList.add('hidden');
      document.body.style.cursor = 'default';

      // Get current camera state
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const startTargetPos = { x: controls.target.x, y: controls.target.y, z: controls.target.z };

      const duration = 1500; // ms
      const startTime = Date.now();

      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function (ease-in-out)
        const eased = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        // Interpolate camera position
        camera.position.x = startCamPos.x + (endPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (endPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (endPos.z - startCamPos.z) * eased;

        // Interpolate target
        controls.target.x = startTargetPos.x + (endTarget.x - startTargetPos.x) * eased;
        controls.target.y = startTargetPos.y + (endTarget.y - startTargetPos.y) * eased;
        controls.target.z = startTargetPos.z + (endTarget.z - startTargetPos.z) * eased;

        camera.lookAt(controls.target);

        // Fade in screen glow at 50%
        if (progress > 0.5) {
          document.getElementById('screen-glow').classList.add('active');
        }

        // Fade out 3D scene at 80%
        if (progress > 0.8) {
          document.getElementById('scene-container').classList.add('fade-out');
        }

        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        } else {
          // Complete - show desktop
          setTimeout(() => {
            document.getElementById('desktop-fullscreen').classList.add('active');
            document.getElementById('back-btn').classList.add('active');
            document.getElementById('screen-glow').classList.remove('active');
            isZooming = false;
            isInDesktop = true;
          }, 300);
        }
      }

      animateZoom();
    }

    // Exit desktop - zoom back out
    function exitDesktop() {
      document.getElementById('desktop-fullscreen').classList.remove('active');
      document.getElementById('back-btn').classList.remove('active');
      document.getElementById('scene-container').classList.remove('fade-out');

      // Reset camera position
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const duration = 800;
      const startTime = Date.now();

      function animateZoomOut() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // ease-out

        camera.position.x = startCamPos.x + (startPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (startPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (startPos.z - startCamPos.z) * eased;

        controls.target.x = endTarget.x + (startTarget.x - endTarget.x) * eased;
        controls.target.y = endTarget.y + (startTarget.y - endTarget.y) * eased;
        controls.target.z = endTarget.z + (startTarget.z - endTarget.z) * eased;

        camera.lookAt(controls.target);

        if (progress < 1) {
          requestAnimationFrame(animateZoomOut);
        } else {
          controls.enabled = true;
          isInDesktop = false;

          // Show UI again
          document.getElementById('controls-hint').classList.remove('hidden');
        }
      }

      animateZoomOut();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (!isZooming) {
        controls.update();
      }

      const time = Date.now() * 0.001;

      // Animate floating clouds
      clouds.forEach(cloud => {
        cloud.position.x += cloud.userData.speed;
        // Reset cloud when it goes too far
        if (cloud.position.x > 15) {
          cloud.position.x = -15;
        }
      });

      // Animate cats with improved walk cycle
      cats.forEach(cat => {
        const ud = cat.userData;
        ud.walkTimer += 0.016;

        // Switch between sitting and walking
        if (ud.isSitting) {
          ud.sitTimer += 0.016;
          if (ud.sitTimer > ud.sitDuration) {
            ud.isSitting = false;
            ud.sitTimer = 0;
            ud.walkDuration = 5 + Math.random() * 5;
            ud.isWalking = true;
          }
          // Sitting pose: legs tucked, body lower, tail relaxed
          if (ud.bodyMesh) ud.bodyMesh.position.y = 0.1;
          cat.position.y = getTerrainHeight(cat.position.x, cat.position.z);
          // Tail gentle sway while sitting
          if (ud.tailSegments) {
            ud.tailSegments.forEach((seg, t) => {
              const progress = t / ud.tailSegments.length;
              seg.position.z = Math.sin(time * 1.5 + progress * 2) * 0.03 * progress;
            });
          }
          // Tuck legs
          if (ud.legs) {
            ud.legs.forEach(leg => {
              leg.rotation.x = 0;
              leg.position.y = 0.05;
            });
          }
        } else {
          // Walking state
          ud.sitTimer += 0.016;
          if (ud.sitTimer > ud.walkDuration) {
            ud.isSitting = true;
            ud.sitTimer = 0;
            ud.sitDuration = 2 + Math.random() * 4;
          }

          // Change direction occasionally
          if (Math.random() < 0.005) {
            ud.direction += (Math.random() - 0.5) * Math.PI;
          }

          // Move cat
          cat.position.x += Math.cos(ud.direction) * ud.speed;
          cat.position.z += Math.sin(ud.direction) * ud.speed;

          // Face walking direction
          cat.rotation.y = -ud.direction + Math.PI / 2;

          // Body bob while walking (follow terrain)
          cat.position.y = getTerrainHeight(cat.position.x, cat.position.z) + 0.02 + Math.sin(time * 10) * 0.01;
          if (ud.bodyMesh) ud.bodyMesh.position.y = 0.14 + Math.sin(time * 10) * 0.005;

          // Leg walk animation (front/back pairs alternate)
          if (ud.legs) {
            const walkCycle = time * 8;
            ud.legs[0].rotation.x = Math.sin(walkCycle) * 0.35;       // front left
            ud.legs[1].rotation.x = Math.sin(walkCycle + Math.PI) * 0.35; // front right
            ud.legs[2].rotation.x = Math.sin(walkCycle + Math.PI) * 0.35; // back left
            ud.legs[3].rotation.x = Math.sin(walkCycle) * 0.35;       // back right
          }

          // Tail sway side to side while walking
          if (ud.tailSegments) {
            ud.tailSegments.forEach((seg, t) => {
              const progress = t / ud.tailSegments.length;
              seg.position.z = Math.sin(time * 3 + progress * 2) * 0.05 * progress;
            });
          }

          // Keep cat in bounds
          if (Math.abs(cat.position.x) > 5) ud.direction = Math.PI - ud.direction;
          if (cat.position.z < 0.5 || cat.position.z > 6) ud.direction = -ud.direction;
        }
      });

      // Animate sleeping person (gentle breathing)
      if (sleepingPerson) {
        const sp = sleepingPerson.userData;
        const breathe = Math.sin(time * 1.2 + sp.breathePhase) * 0.005;
        if (sp.torso) {
          sp.torso.position.y = 0.82 + breathe;
        }
        if (sp.head) {
          sp.head.position.y = 0.58 + breathe * 0.5;
        }
        if (sp.upperBack) {
          sp.upperBack.position.y = 0.88 + breathe;
        }
      }

      // Animate dog (tail wag + gentle breathing)
      if (dog) {
        const dd = dog.userData;
        // Tail wagging (happy, side to side)
        if (dd.tailSegments) {
          dd.tailSegments.forEach((seg, t) => {
            const progress = t / dd.tailSegments.length;
            seg.position.z = Math.sin(time * 6 + progress * 1.5) * 0.08 * progress;
            seg.position.y = 0.18 + Math.sin(progress * Math.PI * 0.6) * 0.12 + Math.abs(Math.sin(time * 6)) * 0.02 * progress;
          });
        }
        // Gentle breathing
        const dogBreathe = Math.sin(time * 1.5 + dd.breathePhase) * 0.004;
        if (dd.bodyMesh) {
          dd.bodyMesh.position.y = 0.16 + dogBreathe;
        }
        // Tongue slight bob
        if (dd.tongue) {
          dd.tongue.position.y = 0.16 + Math.sin(time * 2) * 0.003;
        }
      }

      // Animate rabbits (occasional hopping)
      rabbits.forEach(rabbit => {
        const rd = rabbit.userData;
        rd.hopTimer += 0.016;

        if (!rd.isHopping && rd.hopTimer > rd.hopInterval) {
          rd.isHopping = true;
          rd.hopProgress = 0;
          rd.hopTimer = 0;
          rd.hopDirection = Math.random() * Math.PI * 2;
          rd.hopInterval = 3 + Math.random() * 4;
        }

        if (rd.isHopping) {
          rd.hopProgress += 0.03;
          // Arc hop: up and forward
          const hopArc = Math.sin(rd.hopProgress * Math.PI);
          rabbit.position.y = rd.baseY + hopArc * 0.15;
          rabbit.position.x += Math.cos(rd.hopDirection) * 0.008;
          rabbit.position.z += Math.sin(rd.hopDirection) * 0.008;

          // Slight body tilt during hop
          rabbit.rotation.z = Math.sin(rd.hopProgress * Math.PI) * 0.15;

          if (rd.hopProgress >= 1) {
            rd.isHopping = false;
            rd.baseY = getTerrainHeight(rabbit.position.x, rabbit.position.z);
            rabbit.position.y = rd.baseY;
            rabbit.rotation.z = 0;
            rd.baseX = rabbit.position.x;
            rd.baseZ = rabbit.position.z;
          }

          // Keep rabbits in bounds
          if (Math.abs(rabbit.position.x) > 5) {
            rd.hopDirection = Math.PI - rd.hopDirection;
          }
          if (rabbit.position.z < 1 || rabbit.position.z > 6) {
            rd.hopDirection = -rd.hopDirection;
          }
        }

        // Face hop direction when hopping
        if (rd.isHopping) {
          rabbit.rotation.y = -rd.hopDirection + Math.PI / 2;
        }

        // Ear twitch and nose wiggle (always)
        // Subtle ear sway
      });

      // Animate squirrels (scurrying near trees)
      squirrels.forEach(sq => {
        const sd = sq.userData;
        sd.scurryTimer += 0.016;

        if (!sd.isScurrying && sd.scurryTimer > sd.scurryInterval) {
          sd.isScurrying = true;
          sd.scurryProgress = 0;
          sd.scurryTimer = 0;
          sd.scurryDirection = Math.random() * Math.PI * 2;
          sd.scurryDistance = 0.3 + Math.random() * 0.5;
          sd.scurryInterval = 3 + Math.random() * 5;
          sd.startX = sq.position.x;
          sd.startZ = sq.position.z;
        }

        if (sd.isScurrying) {
          sd.scurryProgress += 0.025;

          // Fast scurry motion
          const scurrySpeed = 0.015;
          sq.position.x += Math.cos(sd.scurryDirection) * scurrySpeed;
          sq.position.z += Math.sin(sd.scurryDirection) * scurrySpeed;

          // Bobbing while scurrying (on terrain)
          sd.groundY = getTerrainHeight(sq.position.x, sq.position.z);
          sq.position.y = sd.groundY + Math.abs(Math.sin(sd.scurryProgress * Math.PI * 8)) * 0.03;

          // Face direction
          sq.rotation.y = -sd.scurryDirection + Math.PI / 2;

          if (sd.scurryProgress >= 1) {
            sd.isScurrying = false;
            sd.groundY = getTerrainHeight(sq.position.x, sq.position.z);
            sq.position.y = sd.groundY;
          }

          // Keep near trees
          if (Math.abs(sq.position.x) > 7) {
            sd.scurryDirection = Math.PI - sd.scurryDirection;
          }
          if (sq.position.z < -8 || sq.position.z > -1) {
            sd.scurryDirection = -sd.scurryDirection;
          }
        }

        // Tail sway (always)
        if (sd.tailSegments) {
          sd.tailSegments.forEach((seg, t) => {
            const progress = t / sd.tailSegments.length;
            const swaySpeed = sd.isScurrying ? 8 : 2;
            const swayAmt = sd.isScurrying ? 0.06 : 0.02;
            seg.position.z = Math.sin(time * swaySpeed + progress * 2) * swayAmt * progress;
          });
        }
      });

      // Animate birds (flocking + wing flap)
      birds.forEach(bird => {
        const bd = bird.userData;
        const bTime = time * bd.speed + bd.phase;

        // Circular flocking motion
        bird.position.x = bd.flockCenterX + Math.sin(bTime) * bd.radius;
        bird.position.z = bd.flockCenterZ + Math.cos(bTime) * bd.radius;
        bird.position.y = bd.flockY + Math.sin(bTime * 1.5) * 0.5;

        // Occasional swooping
        bd.swoopTimer += 0.016;
        if (!bd.isSwooping && bd.swoopTimer > 15 + Math.random() * 10) {
          bd.isSwooping = true;
          bd.swoopProgress = 0;
          bd.swoopTimer = 0;
        }
        if (bd.isSwooping) {
          bd.swoopProgress += 0.02;
          bird.position.y -= Math.sin(bd.swoopProgress * Math.PI) * 2;
          if (bd.swoopProgress >= 1) {
            bd.isSwooping = false;
          }
        }

        // Face direction of movement (tangent to circle)
        bird.rotation.y = -bTime + Math.PI / 2;

        // Bank/tilt when turning
        bird.rotation.z = Math.cos(bTime) * 0.3;

        // Wing flapping
        const wingFlap = Math.sin(time * bd.wingSpeed) * 0.7;
        bird.children.forEach(child => {
          if (child.name === 'leftWing') {
            child.rotation.x = wingFlap;
          } else if (child.name === 'rightWing') {
            child.rotation.x = -wingFlap;
          }
        });
      });

      // Animate trees (subtle canopy sway using absolute offsets)
      trees.forEach(tree => {
        const td = tree.userData;
        td.canopySpheres.forEach((puff, idx) => {
          puff.position.x = puff.userData.origX + Math.sin(time * td.swaySpeed + td.swayPhase + idx * 0.5) * td.swayAmount;
          puff.position.z = puff.userData.origZ + Math.cos(time * td.swaySpeed * 0.7 + td.swayPhase + idx * 0.3) * td.swayAmount * 0.7;
        });
      });

      // Animate pond ripples
      if (pond && pondGeometry) {
        const posArray = pondGeometry.attributes.position.array;
        const orig = pond.userData.originalPositions;
        for (let i = 0; i < posArray.length; i += 3) {
          const ox = orig[i];
          const oy = orig[i + 1];
          const dist = Math.sqrt(ox * ox + oy * oy);
          // Gentle ripple effect on the Z axis (which is Y in world space since it's rotated)
          posArray[i + 2] = Math.sin(dist * 4 - time * 2) * 0.015 * (1 - dist / 1.5);
        }
        pondGeometry.attributes.position.needsUpdate = true;
      }

      // Animate falling leaves
      fallingLeaves.forEach(leaf => {
        const ld = leaf.userData;
        leaf.position.y -= ld.fallSpeed;
        leaf.position.x = ld.startX + Math.sin(time * ld.swaySpeed + ld.phase) * ld.swayAmount;
        leaf.position.z = ld.startZ + Math.cos(time * ld.swaySpeed * 0.7 + ld.phase) * ld.swayAmount * 0.5;
        leaf.rotation.y += ld.spinSpeed * 0.016;
        leaf.rotation.x = Math.sin(time * ld.swaySpeed + ld.phase) * 0.5;

        // Respawn at top when reaching ground
        if (leaf.position.y < -0.3) {
          leaf.position.y = 4 + Math.random() * 4;
          ld.startX = (Math.random() - 0.5) * 12;
          ld.startZ = (Math.random() - 0.5) * 12;
          leaf.position.x = ld.startX;
          leaf.position.z = ld.startZ;
        }
      });

      // Animate butterflies
      butterflies.forEach(bf => {
        const data = bf.userData;
        // Circular flying pattern
        bf.position.x += Math.sin(time * data.speed + data.phase) * 0.01;
        bf.position.z += Math.cos(time * data.speed + data.phase) * 0.01;
        bf.position.y = data.baseY + Math.sin(time * 2 + data.phase) * 0.15;

        // Face direction of movement
        bf.rotation.y = time * data.speed + data.phase;

        // Wing flapping
        if (bf.children[0]) {
          bf.children[0].rotation.y = Math.sin(time * 15 + data.wingPhase) * 0.5;
        }
        if (bf.children[1]) {
          bf.children[1].rotation.y = -Math.sin(time * 15 + data.wingPhase) * 0.5;
        }
      });

      // Animate coffee steam
      steamParticles.forEach(s => {
        s.position.y += 0.001 * s.userData.speed;
        s.material.opacity = 0.15 * (1 - (s.position.y - s.userData.baseY) / 0.15);
        if (s.position.y > s.userData.baseY + 0.15) {
          s.position.y = s.userData.baseY;
          s.position.x = 1.1 + (Math.random()-0.5)*0.03;
        }
      });

      // Subtle screen flicker
      if (screenLight) {
        screenLight.intensity = 0.5 + Math.sin(time * 3) * 0.02 + Math.random() * 0.01;
      }

      if (composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) composer.setSize(window.innerWidth, window.innerHeight);
      if (fxaaPass) {
        fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
      }
    }

    window.addEventListener('resize', onWindowResize);

    // ESC to exit desktop
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isInDesktop) {
        exitDesktop();
      }
    });

    // Listen for messages from iframe (e.g., shutdown -> power on)
    window.addEventListener('message', (e) => {
      if (e.data === 'exitDesktop' && isInDesktop) {
        exitDesktop();
      }
    });

    // Mobile redirect
    if (/Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768) {
      window.location.href = 'mobile.html';
    }

    // Initialize
    init();
  </script>
</body>
</html>
<!-- v2.3.0 - fixed screen glitch and clipping issues -->
