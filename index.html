<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyle | 3D Desktop</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='r' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ff5f5f'/%3E%3Cstop offset='100%25' stop-color='%23cc0000'/%3E%3C/linearGradient%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2355ff55'/%3E%3Cstop offset='100%25' stop-color='%2300aa00'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%235599ff'/%3E%3Cstop offset='100%25' stop-color='%230044cc'/%3E%3C/linearGradient%3E%3ClinearGradient id='y' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffee55'/%3E%3Cstop offset='100%25' stop-color='%23ccaa00'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x='2' y='2' width='13' height='13' rx='2' fill='url(%23r)'/%3E%3Crect x='17' y='2' width='13' height='13' rx='2' fill='url(%23g)'/%3E%3Crect x='2' y='17' width='13' height='13' rx='2' fill='url(%23b)'/%3E%3Crect x='17' y='17' width='13' height='13' rx='2' fill='url(%23y)'/%3E%3C/svg%3E">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Tahoma', sans-serif;
    }

    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      transition: opacity 0.5s ease;
    }

    #scene-container.fade-out {
      opacity: 0;
    }

    /* Controls hint */
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: #fff;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 12px 25px;
      border-radius: 8px;
      transition: opacity 0.3s;
      text-align: center;
    }

    .controls-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .controls-hint .main {
      font-size: 16px;
      margin-bottom: 5px;
    }

    .controls-hint .sub {
      font-size: 11px;
      color: #888;
    }

    /* Fullscreen desktop mode */
    .desktop-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .desktop-fullscreen.active {
      opacity: 1;
      pointer-events: auto;
    }

    .desktop-fullscreen iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Back button when in desktop mode */
    .back-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 1001;
      background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
      color: #fff;
      border: 2px solid #666;
      padding: 10px 20px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 5px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s, transform 0.2s;
      font-family: 'Tahoma', sans-serif;
    }

    .back-btn:hover {
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      transform: scale(1.05);
    }

    .back-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Screen glow overlay during transition */
    .screen-glow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, rgba(100,180,255,0.3) 0%, transparent 70%);
      z-index: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .screen-glow.active {
      opacity: 1;
    }

    /* Monitor highlight on hover */
    .click-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      background: rgba(0,100,200,0.8);
      padding: 15px 30px;
      border-radius: 10px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .click-hint.visible {
      opacity: 1;
    }
      /* Mobile overlay */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      z-index: 9999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }

    .mobile-overlay.show {
      display: flex;
    }

    .mobile-overlay h1 {
      color: #fff;
      font-size: 28px;
      margin-bottom: 10px;
    }

    .mobile-overlay p {
      color: #888;
      font-size: 14px;
      max-width: 300px;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .mobile-overlay .links {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 280px;
    }

    .mobile-overlay a {
      background: linear-gradient(180deg, #5b8def 0%, #3a6bc5 100%);
      color: #fff;
      text-decoration: none;
      padding: 14px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .mobile-overlay .skip-btn {
      background: transparent;
      border: 1px solid #444;
      color: #666;
      padding: 10px;
      margin-top: 20px;
      cursor: pointer;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      .mobile-overlay {
        display: flex;
      }
    }

    /* Music Toggle Button */
    .music-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      color: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background 0.2s;
    }
    .music-toggle:hover {
      background: rgba(0, 0, 0, 0.8);
    }
    .music-toggle.muted {
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <!-- Music Toggle Button -->
  <button class="music-toggle" id="music-toggle" onclick="toggleMusicBtn()">
    <span id="music-icon">üîä</span>
    <span id="music-text">Music</span>
  </button>
  <!-- Mobile Overlay -->
  <div class="mobile-overlay" id="mobile-overlay">
    <h1>Kyle Kumar</h1>
    <p>This portfolio is best experienced on desktop. It features a 3D interactive room with a Windows XP desktop simulation.</p>
    <div class="links">
      <a href="https://github.com/ergophobian" target="_blank">GitHub @ergophobian</a>
      <a href="https://tiktok.com/@ergophobian" target="_blank">TikTok @ergophobian</a>
      <a href="https://x.com/indefatigabile" target="_blank">X @indefatigabile</a>
    </div>
    <button class="skip-btn" onclick="document.getElementById('mobile-overlay').classList.remove('show');">
      Continue to desktop version anyway
    </button>
  </div>

  <!-- 3D Scene -->
  <div id="scene-container"></div>

  <!-- Controls hint -->
  <div class="controls-hint" id="controls-hint">
    <div class="main">Click the monitor to enter</div>
    <div class="sub">Drag to rotate ‚Ä¢ Scroll to zoom</div>
  </div>

  <!-- Click hint on monitor hover -->
  <div class="click-hint" id="click-hint">Click to Enter Desktop</div>

  <!-- Screen glow transition -->
  <div class="screen-glow" id="screen-glow"></div>

  <!-- Fullscreen desktop overlay -->
  <div class="desktop-fullscreen" id="desktop-fullscreen">
    <iframe src="desktop.html" id="desktop-iframe"></iframe>
  </div>

  <!-- Back button -->
  <button class="back-btn" id="back-btn" onclick="exitDesktop()">‚Üê Back to 3D View</button>

  <!-- Hidden YouTube Player for Music -->
  <div id="yt-player" style="position: absolute; left: -9999px; top: -9999px;"></div>

  <script>
    // ========== YOUTUBE MUSIC PLAYER ==========
    let ytPlayer = null;
    let isMusicPlaying = false;
    let musicInitialized = false;

    function onYouTubeIframeAPIReady() {
      ytPlayer = new YT.Player('yt-player', {
        height: '0',
        width: '0',
        videoId: 'RSFqIWudfq0', // Yabujin Flash Cassanova slowed
        playerVars: {
          autoplay: 0,
          loop: 1,
          playlist: 'RSFqIWudfq0',
          controls: 0,
          disablekb: 1,
          modestbranding: 1
        },
        events: {
          onReady: function(event) {
            ytPlayer.setVolume(30);
            musicInitialized = true;
          },
          onStateChange: function(event) {
            if (event.data === YT.PlayerState.ENDED) {
              ytPlayer.playVideo();
            }
          }
        }
      });
    }

    function startMusic() {
      if (musicInitialized && ytPlayer && !isMusicPlaying) {
        ytPlayer.playVideo();
        isMusicPlaying = true;
      }
    }

    function stopMusic() {
      if (ytPlayer && isMusicPlaying) {
        ytPlayer.pauseVideo();
        isMusicPlaying = false;
      }
    }

    function toggleMusicBtn() {
      const btn = document.getElementById('music-toggle');
      const icon = document.getElementById('music-icon');
      const text = document.getElementById('music-text');

      if (!musicInitialized || !ytPlayer) {
        return;
      }

      if (isMusicPlaying) {
        ytPlayer.pauseVideo();
        isMusicPlaying = false;
        icon.textContent = 'üîá';
        text.textContent = 'Muted';
        btn.classList.add('muted');
      } else {
        ytPlayer.playVideo();
        isMusicPlaying = true;
        icon.textContent = 'üîä';
        text.textContent = 'Music';
        btn.classList.remove('muted');
      }
    }
  </script>

  <script>
    // ============ SATISFYING SOUNDS ============
    let audioCtx = null;
    let hissNode = null;
    let hissGain = null;

    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    // Preload sounds
    const sounds = {
      keypress: new Audio('sounds/keypress.mp3'),
      enter: new Audio('sounds/enter.ogg'),
      click: new Audio('sounds/open-window.ogg')
    };

    // Set volumes
    sounds.keypress.volume = 0.4;
    sounds.enter.volume = 0.5;
    sounds.click.volume = 0.3;

    // Mechanical keyboard sound
    function playKeySound() {
      try {
        const sound = sounds.keypress.cloneNode();
        sound.volume = 0.3 + Math.random() * 0.2;
        sound.playbackRate = 0.95 + Math.random() * 0.1;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Click sound
    function playClickSound() {
      try {
        const sound = sounds.click.cloneNode();
        sound.volume = 0.3;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Enter/confirmation sound
    function playEnterSound() {
      try {
        sounds.enter.currentTime = 0;
        sounds.enter.play().catch(() => {});
      } catch(e) {}
    }

    // Background hiss (CRT static)
    function startBackgroundHiss() {
      try {
        const ctx = getAudioCtx();
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        hissNode = ctx.createBufferSource();
        hissNode.buffer = noiseBuffer;
        hissNode.loop = true;

        // Filter to make it a softer hiss
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        hissGain = ctx.createGain();
        hissGain.gain.value = 0.015; // Very quiet

        hissNode.connect(filter);
        filter.connect(hissGain);
        hissGain.connect(ctx.destination);

        hissNode.start();
      } catch(e) {}
    }

    // Keyboard listener for mechanical sounds (only when in desktop mode)
    document.addEventListener('keydown', (e) => {
      if (!e.repeat && isInDesktop) playKeySound();
    });

    // Start hiss on first interaction (very subtle)
    let hissStarted = false;
    function maybeStartHiss() {
      if (!hissStarted) {
        hissStarted = true;
        startBackgroundHiss();
      }
    }

    // Three.js Scene
    let scene, camera, renderer, controls;
    let screenMesh; // Reference to clickable screen
    let isZooming = false;
    let isInDesktop = false;

    // Camera animation
    const startPos = { x: 0, y: 2, z: 4 };
    const endPos = { x: 0, y: 1.15, z: 0.8 }; // Close to screen
    const startTarget = { x: 0, y: 1, z: 0 };
    const endTarget = { x: 0, y: 1.15, z: 0.36 }; // Screen position

    // Raycaster for click detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(startPos.x, startPos.y, startPos.z);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('scene-container').appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 1.5;
      controls.maxDistance = 8;
      controls.maxPolarAngle = Math.PI / 2;
      controls.target.set(startTarget.x, startTarget.y, startTarget.z);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Add slight point light on screen for glow effect
      const screenLight = new THREE.PointLight(0x4488ff, 0.5, 3);
      screenLight.position.set(0, 1.15, 0.5);
      scene.add(screenLight);

      // Create scene objects
      createRoom();
      createDesk();
      createMonitor();
      createKeyboard();
      createMouse();
      createDecorations();
      createCats();

      // Mouse/click events
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      // Start animation
      animate();
    }

    // Floating clouds array
    let clouds = [];
    // Butterflies array
    let butterflies = [];

    function createRoom() {
      // WINDOWS XP BLISS - Authentic rolling green hills

      // Create smooth hilly terrain with higher resolution
      const terrainGeometry = new THREE.PlaneGeometry(60, 60, 128, 128);
      const vertices = terrainGeometry.attributes.position.array;

      // Smooth rolling hills - authentic XP Bliss feel
      for (let i = 0; i < vertices.length; i += 3) {
        const x = vertices[i];
        const y = vertices[i + 1];
        // Multiple sine waves for natural rolling hills
        const hill1 = Math.sin(x * 0.15) * Math.cos(y * 0.1) * 0.8;
        const hill2 = Math.sin(x * 0.08 + 0.5) * Math.sin(y * 0.12) * 0.5;
        const hill3 = Math.cos(x * 0.05 + y * 0.05) * 0.6;
        const micro = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.05; // Subtle micro detail
        vertices[i + 2] = hill1 + hill2 + hill3 + micro;
      }
      terrainGeometry.computeVertexNormals();

      // Grass green with subtle vertex colors for variation
      const terrainMaterial = new THREE.MeshStandardMaterial({
        color: 0x3CB043, // Authentic XP Bliss green
        roughness: 0.85,
        metalness: 0,
        flatShading: false
      });
      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrain.rotation.x = -Math.PI / 2;
      terrain.position.y = -0.5;
      terrain.receiveShadow = true;
      scene.add(terrain);

      // Add grass tufts for texture
      createGrassTufts();

      // Add wildflowers
      createWildflowers();

      // === WINDOWS XP BLISS SKY ===
      scene.background = null;
      const skyGeometry = new THREE.SphereGeometry(80, 64, 64);
      const skyCanvas = document.createElement('canvas');
      skyCanvas.width = 2048;
      skyCanvas.height = 1024;
      const skyCtx = skyCanvas.getContext('2d');

      // Authentic XP Bliss sky gradient
      const skyGrad = skyCtx.createLinearGradient(0, 0, 0, skyCanvas.height);
      skyGrad.addColorStop(0, '#1565C0');     // Deep blue at zenith
      skyGrad.addColorStop(0.15, '#1E88E5');  // Rich blue
      skyGrad.addColorStop(0.3, '#42A5F5');   // Medium blue
      skyGrad.addColorStop(0.45, '#64B5F6');  // Lighter blue
      skyGrad.addColorStop(0.6, '#90CAF9');   // Light blue
      skyGrad.addColorStop(0.75, '#BBDEFB');  // Very light blue
      skyGrad.addColorStop(0.9, '#E3F2FD');   // Near white at horizon
      skyGrad.addColorStop(1, '#F5F9FF');     // White horizon
      skyCtx.fillStyle = skyGrad;
      skyCtx.fillRect(0, 0, skyCanvas.width, skyCanvas.height);

      // Draw fluffy cumulus clouds on sky texture
      function drawCloud(ctx, x, y, scale) {
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        const s = scale;
        // Multiple overlapping circles for fluffy appearance
        ctx.beginPath();
        ctx.arc(x, y, 35*s, 0, Math.PI * 2);
        ctx.arc(x + 30*s, y - 15*s, 30*s, 0, Math.PI * 2);
        ctx.arc(x + 55*s, y - 5*s, 32*s, 0, Math.PI * 2);
        ctx.arc(x + 80*s, y, 28*s, 0, Math.PI * 2);
        ctx.arc(x + 25*s, y + 12*s, 25*s, 0, Math.PI * 2);
        ctx.arc(x + 55*s, y + 15*s, 27*s, 0, Math.PI * 2);
        ctx.arc(x + 40*s, y - 8*s, 28*s, 0, Math.PI * 2);
        ctx.fill();

        // Subtle shadow on bottom of cloud
        ctx.fillStyle = 'rgba(200,210,220,0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 40*s, y + 20*s, 50*s, 12*s, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // Scattered clouds across the sky
      drawCloud(skyCtx, 150, 200, 1.2);
      drawCloud(skyCtx, 500, 150, 1.5);
      drawCloud(skyCtx, 900, 220, 1.1);
      drawCloud(skyCtx, 1300, 180, 1.4);
      drawCloud(skyCtx, 1700, 160, 1.3);
      drawCloud(skyCtx, 300, 350, 0.9);
      drawCloud(skyCtx, 750, 380, 1.0);
      drawCloud(skyCtx, 1150, 340, 1.1);
      drawCloud(skyCtx, 1550, 370, 0.95);
      drawCloud(skyCtx, 1900, 320, 1.2);

      const skyTexture = new THREE.CanvasTexture(skyCanvas);
      skyTexture.minFilter = THREE.LinearFilter;
      const skyMaterial = new THREE.MeshBasicMaterial({
        map: skyTexture,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // === 3D FLOATING CLOUDS ===
      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.95,
        roughness: 1,
        metalness: 0
      });

      // Create more realistic puffy clouds
      for (let i = 0; i < 12; i++) {
        const cloudGroup = new THREE.Group();
        // Randomized cloud shapes
        const numPuffs = 5 + Math.floor(Math.random() * 4);
        for (let j = 0; j < numPuffs; j++) {
          const size = 0.3 + Math.random() * 0.4;
          const puff = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 12), cloudMaterial);
          puff.position.set(
            (j - numPuffs/2) * 0.35 + Math.random() * 0.2,
            Math.random() * 0.2,
            Math.random() * 0.3 - 0.15
          );
          puff.scale.y = 0.6 + Math.random() * 0.3; // Flatten slightly
          cloudGroup.add(puff);
        }
        cloudGroup.position.set(
          (Math.random() - 0.5) * 30,
          4 + Math.random() * 5,
          -12 - Math.random() * 15
        );
        cloudGroup.userData = {
          speed: 0.003 + Math.random() * 0.007,
          startX: cloudGroup.position.x
        };
        clouds.push(cloudGroup);
        scene.add(cloudGroup);
      }

      // Create butterflies
      createButterflies();
    }

    function createGrassTufts() {
      // Scattered grass tufts for texture
      const grassMaterial = new THREE.MeshStandardMaterial({
        color: 0x2E7D32,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      for (let i = 0; i < 100; i++) {
        const tuft = new THREE.Group();
        // Each tuft has 3-5 blades
        const numBlades = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < numBlades; j++) {
          const blade = new THREE.Mesh(
            new THREE.ConeGeometry(0.015, 0.1 + Math.random() * 0.05, 4),
            grassMaterial
          );
          blade.position.set(
            (Math.random() - 0.5) * 0.05,
            0.04,
            (Math.random() - 0.5) * 0.05
          );
          blade.rotation.x = (Math.random() - 0.5) * 0.3;
          blade.rotation.z = (Math.random() - 0.5) * 0.3;
          tuft.add(blade);
        }
        tuft.position.set(
          (Math.random() - 0.5) * 15,
          -0.45,
          (Math.random() - 0.5) * 15
        );
        scene.add(tuft);
      }
    }

    function createWildflowers() {
      // Scattered wildflowers like in Windows XP Bliss
      const flowerColors = [0xFFEB3B, 0xFFFFFF, 0xFF7043, 0xE91E63, 0x9C27B0]; // Yellow, white, orange, pink, purple

      for (let i = 0; i < 50; i++) {
        const flower = new THREE.Group();
        const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];

        // Stem
        const stem = new THREE.Mesh(
          new THREE.CylinderGeometry(0.005, 0.005, 0.08 + Math.random() * 0.04, 6),
          new THREE.MeshStandardMaterial({ color: 0x33691E })
        );
        stem.position.y = 0.04;
        flower.add(stem);

        // Petals (simple)
        const petalMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
        for (let p = 0; p < 5; p++) {
          const petal = new THREE.Mesh(
            new THREE.SphereGeometry(0.015, 6, 6),
            petalMat
          );
          const angle = (p / 5) * Math.PI * 2;
          petal.position.set(
            Math.cos(angle) * 0.02,
            0.085,
            Math.sin(angle) * 0.02
          );
          petal.scale.y = 0.5;
          flower.add(petal);
        }

        // Center
        const center = new THREE.Mesh(
          new THREE.SphereGeometry(0.01, 6, 6),
          new THREE.MeshStandardMaterial({ color: 0xFFC107 })
        );
        center.position.y = 0.085;
        flower.add(center);

        flower.position.set(
          (Math.random() - 0.5) * 12,
          -0.48,
          (Math.random() - 0.5) * 12
        );
        scene.add(flower);
      }
    }

    function createButterflies() {
      // Animated butterflies floating around
      const butterflyColors = [0xFF9800, 0x2196F3, 0xFFEB3B, 0xE91E63];

      for (let i = 0; i < 6; i++) {
        const butterfly = new THREE.Group();
        const color = butterflyColors[Math.floor(Math.random() * butterflyColors.length)];
        const wingMat = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          side: THREE.DoubleSide
        });

        // Wings (simple triangular shapes)
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(0.03, 0.02);
        wingShape.lineTo(0.025, -0.02);
        wingShape.lineTo(0, 0);

        const wingGeo = new THREE.ShapeGeometry(wingShape);

        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.x = 0.005;
        butterfly.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.scale.x = -1;
        rightWing.position.x = -0.005;
        butterfly.add(rightWing);

        // Body
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.003, 0.002, 0.025, 6),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        body.rotation.x = Math.PI / 2;
        butterfly.add(body);

        butterfly.position.set(
          (Math.random() - 0.5) * 6,
          0.5 + Math.random() * 1.5,
          (Math.random() - 0.5) * 6
        );

        butterfly.userData = {
          baseY: butterfly.position.y,
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 0.5,
          radius: 0.5 + Math.random() * 1,
          wingPhase: Math.random() * Math.PI * 2
        };

        butterflies.push(butterfly);
        scene.add(butterfly);
      }
    }

    // Cats array
    let cats = [];

    function createCats() {
      const catColors = [0xFFFFFF, 0x333333, 0xFFAA00, 0x888888]; // White, black, orange, gray

      for (let i = 0; i < 3; i++) {
        const catGroup = new THREE.Group();
        const catColor = catColors[Math.floor(Math.random() * catColors.length)];
        const catMaterial = new THREE.MeshStandardMaterial({ color: catColor, roughness: 0.9 });

        // Body (using stretched sphere since CapsuleGeometry not in r128)
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), catMaterial);
        body.scale.set(1.5, 0.8, 0.8);
        body.position.y = 0.1;
        catGroup.add(body);

        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 8), catMaterial);
        head.position.set(0.12, 0.12, 0);
        catGroup.add(head);

        // Ears
        const earGeo = new THREE.ConeGeometry(0.025, 0.05, 4);
        const ear1 = new THREE.Mesh(earGeo, catMaterial);
        ear1.position.set(0.14, 0.2, 0.03);
        catGroup.add(ear1);
        const ear2 = new THREE.Mesh(earGeo, catMaterial);
        ear2.position.set(0.14, 0.2, -0.03);
        catGroup.add(ear2);

        // Tail
        const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.01, 0.15, 8), catMaterial);
        tail.position.set(-0.15, 0.15, 0);
        tail.rotation.z = Math.PI / 4;
        catGroup.add(tail);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8);
        [[-0.05, 0.04, 0.04], [-0.05, 0.04, -0.04], [0.05, 0.04, 0.04], [0.05, 0.04, -0.04]].forEach(pos => {
          const leg = new THREE.Mesh(legGeo, catMaterial);
          leg.position.set(...pos);
          catGroup.add(leg);
        });

        // Position cat on the terrain
        catGroup.position.set(
          (Math.random() - 0.5) * 6,
          -0.35,
          1 + Math.random() * 3
        );

        catGroup.userData = {
          speed: 0.005 + Math.random() * 0.01,
          direction: Math.random() * Math.PI * 2,
          walkTimer: 0,
          isWalking: true
        };

        cats.push(catGroup);
        scene.add(catGroup);
      }
    }

    function createDesk() {
      const deskMaterial = new THREE.MeshStandardMaterial({
        color: 0x5C4033,
        roughness: 0.7
      });

      // Desk top
      const deskTopGeometry = new THREE.BoxGeometry(3, 0.08, 1.5);
      const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
      deskTop.position.set(0, 0.5, 0);
      deskTop.castShadow = true;
      deskTop.receiveShadow = true;
      scene.add(deskTop);

      // Desk legs
      const legGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
      [[-1.4, 0, -0.65], [1.4, 0, -0.65], [-1.4, 0, 0.65], [1.4, 0, 0.65]].forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, deskMaterial);
        leg.position.set(...pos);
        leg.castShadow = true;
        scene.add(leg);
      });
    }

    function createMonitor() {
      // Classic CRT monitor - improved quality
      const monitorColor = 0xD4C5A9; // Beige/off-white classic color
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: monitorColor, roughness: 0.6, metalness: 0.05 });
      const darkPlastic = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });

      // Main monitor body (CRT bulk with beveled appearance)
      const monitorGroup = new THREE.Group();

      // Main body
      const bodyGeometry = new THREE.BoxGeometry(1.15, 0.95, 0.95);
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0, 0);
      body.castShadow = true;
      monitorGroup.add(body);

      // Front face panel (slightly inset)
      const frontPanel = new THREE.Mesh(
        new THREE.BoxGeometry(1.1, 0.9, 0.05),
        bodyMaterial
      );
      frontPanel.position.set(0, 0.02, 0.48);
      monitorGroup.add(frontPanel);

      // Screen bezel (dark frame around screen)
      const bezelOuter = new THREE.Mesh(
        new THREE.BoxGeometry(0.95, 0.75, 0.03),
        darkPlastic
      );
      bezelOuter.position.set(0, 0.05, 0.52);
      monitorGroup.add(bezelOuter);

      // Inner bezel lip (slight depth)
      const bezelInner = new THREE.Mesh(
        new THREE.BoxGeometry(0.88, 0.68, 0.02),
        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 })
      );
      bezelInner.position.set(0, 0.05, 0.535);
      monitorGroup.add(bezelInner);

      // Ventilation slots on sides
      const ventMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 });
      for (let i = 0; i < 6; i++) {
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.08, 0.4), ventMat);
        vent.position.set(0.58, 0.25 - i * 0.1, 0);
        monitorGroup.add(vent);
        const vent2 = vent.clone();
        vent2.position.x = -0.58;
        monitorGroup.add(vent2);
      }

      // Bottom control panel area
      const controlPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.08, 0.05),
        new THREE.MeshStandardMaterial({ color: 0xc0b8a0, roughness: 0.5 })
      );
      controlPanel.position.set(0, -0.35, 0.52);
      monitorGroup.add(controlPanel);

      // Control buttons
      const buttonMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.3 });
      for (let i = 0; i < 4; i++) {
        const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.02, 8), buttonMat);
        btn.rotation.x = Math.PI / 2;
        btn.position.set(-0.15 + i * 0.08, -0.35, 0.54);
        monitorGroup.add(btn);
      }

      // Power LED
      const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
      const led = new THREE.Mesh(new THREE.CircleGeometry(0.012, 12), ledMaterial);
      led.position.set(0.22, -0.35, 0.545);
      monitorGroup.add(led);

      // Brand logo area (subtle indent)
      const logoArea = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.025, 0.01),
        new THREE.MeshStandardMaterial({ color: 0xb8b0a0, roughness: 0.3 })
      );
      logoArea.position.set(0, -0.42, 0.52);
      monitorGroup.add(logoArea);

      monitorGroup.position.set(0, 1.1, -0.18);
      scene.add(monitorGroup);

      // === SCREEN with scan lines effect ===
      const screenGeometry = new THREE.PlaneGeometry(0.82, 0.62);

      // Create XP desktop texture with scan lines
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 768;
      const ctx = canvas.getContext('2d');

      // XP Bliss background - authentic colors
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1E5BC6');    // Deep blue
      gradient.addColorStop(0.3, '#3A7BD5');
      gradient.addColorStop(0.6, '#5A9BD5');
      gradient.addColorStop(1, '#8ECAE6');    // Light blue at horizon
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Rolling hills - multiple layers for depth
      // Back hill
      ctx.fillStyle = '#2D8F38';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(200, 450, 400, 350, 600, 420);
      ctx.bezierCurveTo(800, 490, 900, 380, 1024, 450);
      ctx.lineTo(1024, canvas.height);
      ctx.fill();

      // Middle hill
      ctx.fillStyle = '#3CB043';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(150, 480, 350, 400, 512, 470);
      ctx.bezierCurveTo(700, 540, 850, 420, 1024, 500);
      ctx.lineTo(1024, canvas.height);
      ctx.fill();

      // Front hill - brightest
      ctx.fillStyle = '#4ADE54';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(256, 580, 512, 520, 768, 580);
      ctx.bezierCurveTo(900, 620, 1000, 550, 1024, canvas.height - 100);
      ctx.lineTo(1024, canvas.height);
      ctx.fill();

      // Fluffy clouds
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      const cloudPositions = [
        [120, 100, 45], [280, 140, 55], [450, 90, 50],
        [620, 130, 48], [780, 100, 52], [920, 150, 45]
      ];
      cloudPositions.forEach(([x, y, r]) => {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.arc(x + r*0.6, y - r*0.35, r*0.75, 0, Math.PI * 2);
        ctx.arc(x + r*1.1, y - r*0.1, r*0.85, 0, Math.PI * 2);
        ctx.arc(x + r*1.5, y + r*0.1, r*0.7, 0, Math.PI * 2);
        ctx.arc(x + r*0.3, y + r*0.25, r*0.6, 0, Math.PI * 2);
        ctx.fill();
      });

      // Slight screen curvature vignette
      const vignetteGrad = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, canvas.width * 0.3,
        canvas.width/2, canvas.height/2, canvas.width * 0.7
      );
      vignetteGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vignetteGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
      ctx.fillStyle = vignetteGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Desktop icons
      ctx.fillStyle = '#fff';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 2;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;

      const icons = [
        { name: 'My Computer', y: 50 },
        { name: 'Recycle Bin', y: 130 },
        { name: 'My Documents', y: 210 }
      ];
      icons.forEach(icon => {
        // Icon box
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(30, icon.y, 48, 48);
        // Icon text
        ctx.fillStyle = '#fff';
        ctx.font = '11px Tahoma';
        ctx.textAlign = 'center';
        ctx.fillText(icon.name, 54, icon.y + 65);
      });
      ctx.textAlign = 'left';
      ctx.shadowBlur = 0;

      // Taskbar
      const taskbarGrad = ctx.createLinearGradient(0, canvas.height - 40, 0, canvas.height);
      taskbarGrad.addColorStop(0, '#245ED8');
      taskbarGrad.addColorStop(0.1, '#3168DC');
      taskbarGrad.addColorStop(0.9, '#1941A5');
      taskbarGrad.addColorStop(1, '#1941A5');
      ctx.fillStyle = taskbarGrad;
      ctx.fillRect(0, canvas.height - 40, canvas.width, 40);

      // Start button with gradient
      const startGrad = ctx.createLinearGradient(2, canvas.height - 38, 2, canvas.height - 6);
      startGrad.addColorStop(0, '#3C9C3C');
      startGrad.addColorStop(0.5, '#2D8F2D');
      startGrad.addColorStop(1, '#1E6B1E');
      ctx.fillStyle = startGrad;
      ctx.beginPath();
      ctx.roundRect(2, canvas.height - 38, 100, 32, 5);
      ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.font = 'bold italic 16px Tahoma';
      ctx.fillText('start', 35, canvas.height - 17);

      // Clock in system tray
      ctx.fillStyle = '#fff';
      ctx.font = '11px Tahoma';
      ctx.textAlign = 'right';
      ctx.fillText('4:20 PM', canvas.width - 10, canvas.height - 15);

      const screenTexture = new THREE.CanvasTexture(canvas);
      screenTexture.minFilter = THREE.LinearFilter;
      screenTexture.magFilter = THREE.LinearFilter;
      screenTexture.anisotropy = 4;

      const screenMaterial = new THREE.MeshBasicMaterial({
        map: screenTexture,
        transparent: false
      });

      screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
      screenMesh.position.set(0, 1.15, 0.365);
      screenMesh.name = 'screen';
      scene.add(screenMesh);

      // Screen glass reflection overlay (subtle)
      const glassGeometry = new THREE.PlaneGeometry(0.82, 0.62);
      const glassMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.03
      });
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.set(0, 1.15, 0.367);
      scene.add(glass);

      // Monitor stand (neck)
      const standNeck = new THREE.Mesh(
        new THREE.BoxGeometry(0.35, 0.12, 0.45),
        bodyMaterial
      );
      standNeck.position.set(0, 0.58, -0.15);
      standNeck.castShadow = true;
      scene.add(standNeck);

      // Monitor base (wider foot)
      const baseGeometry = new THREE.BoxGeometry(0.55, 0.04, 0.35);
      const base = new THREE.Mesh(baseGeometry, bodyMaterial);
      base.position.set(0, 0.52, -0.08);
      base.castShadow = true;
      scene.add(base);

      // Tilt adjustment mechanism
      const tiltMech = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.06, 0.02, 16),
        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.3 })
      );
      tiltMech.rotation.x = Math.PI / 2;
      tiltMech.position.set(0, 0.64, -0.2);
      scene.add(tiltMech);
    }

    function createKeyboard() {
      const kbMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });
      const keyMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4 });

      const kbGeometry = new THREE.BoxGeometry(0.6, 0.03, 0.2);
      const kb = new THREE.Mesh(kbGeometry, kbMaterial);
      kb.position.set(0, 0.56, 0.45);
      kb.castShadow = true;
      scene.add(kb);

      // Keys
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 12; col++) {
          const keyGeometry = new THREE.BoxGeometry(0.04, 0.015, 0.04);
          const key = new THREE.Mesh(keyGeometry, keyMaterial);
          key.position.set(-0.25 + col * 0.045, 0.58, 0.38 + row * 0.045);
          scene.add(key);
        }
      }
    }

    function createMouse() {
      const mouseMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });

      const mouseGeometry = new THREE.BoxGeometry(0.06, 0.025, 0.1);
      const mouseMesh = new THREE.Mesh(mouseGeometry, mouseMaterial);
      mouseMesh.position.set(0.5, 0.55, 0.45);
      mouseMesh.castShadow = true;
      scene.add(mouseMesh);

      // Cable
      const cableGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8);
      const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const cable = new THREE.Mesh(cableGeometry, cableMaterial);
      cable.position.set(0.5, 0.54, 0.25);
      cable.rotation.x = Math.PI / 2;
      scene.add(cable);
    }

    function createDecorations() {
      // Plant
      const potMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const potGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 8);
      const pot = new THREE.Mesh(potGeometry, potMaterial);
      pot.position.set(-1.2, 0.62, 0);
      pot.castShadow = true;
      scene.add(pot);

      const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
      for (let i = 0; i < 5; i++) {
        const leafGeometry = new THREE.ConeGeometry(0.03, 0.2, 4);
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(-1.2 + Math.cos(angle) * 0.05, 0.8, Math.sin(angle) * 0.05);
        leaf.rotation.x = 0.3 * Math.cos(angle);
        leaf.rotation.z = 0.3 * Math.sin(angle);
        scene.add(leaf);
      }

      // Coffee mug
      const mugMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3 });
      const mugGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.1, 16);
      const mug = new THREE.Mesh(mugGeometry, mugMaterial);
      mug.position.set(1.1, 0.59, 0.3);
      mug.castShadow = true;
      scene.add(mug);

      const coffeeGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const coffeeMaterial = new THREE.MeshStandardMaterial({ color: 0x3C1810, roughness: 0.2 });
      const coffee = new THREE.Mesh(coffeeGeometry, coffeeMaterial);
      coffee.position.set(1.1, 0.63, 0.3);
      scene.add(coffee);

      // Add workspace details (gaming chair, headphones, energy drinks, etc.)
      createWorkspaceDetails();
    }

    function createWorkspaceDetails() {
      // Developer workspace accessories that look great in low-poly style

      // === GAMING CHAIR (empty, slightly pushed back) ===
      const chairGroup = new THREE.Group();
      const chairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3 });
      const chairRed = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.4 }); // Red accent
      const metalMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.6, roughness: 0.3 });

      // Seat cushion
      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.08, 0.45), chairMat);
      seat.position.y = 0.35;
      chairGroup.add(seat);

      // Seat side bolsters
      const seatBolster = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.4), chairRed);
      seatBolster.position.set(-0.22, 0.38, 0);
      chairGroup.add(seatBolster);
      const seatBolster2 = seatBolster.clone();
      seatBolster2.position.x = 0.22;
      chairGroup.add(seatBolster2);

      // Back rest
      const backRest = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.55, 0.08), chairMat);
      backRest.position.set(0, 0.65, -0.22);
      backRest.rotation.x = 0.1;
      chairGroup.add(backRest);

      // Back bolsters (racing style)
      const backBolster = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.45, 0.1), chairRed);
      backBolster.position.set(-0.2, 0.62, -0.2);
      backBolster.rotation.x = 0.1;
      chairGroup.add(backBolster);
      const backBolster2 = backBolster.clone();
      backBolster2.position.x = 0.2;
      chairGroup.add(backBolster2);

      // Headrest
      const headrest = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.12, 0.08), chairMat);
      headrest.position.set(0, 0.98, -0.22);
      chairGroup.add(headrest);

      // Armrests
      const armrestBase = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.15, 0.04), metalMat);
      armrestBase.position.set(-0.28, 0.42, 0.05);
      chairGroup.add(armrestBase);
      const armrestTop = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.2), chairMat);
      armrestTop.position.set(-0.28, 0.5, 0.05);
      chairGroup.add(armrestTop);
      const armrestBase2 = armrestBase.clone();
      armrestBase2.position.x = 0.28;
      chairGroup.add(armrestBase2);
      const armrestTop2 = armrestTop.clone();
      armrestTop2.position.x = 0.28;
      chairGroup.add(armrestTop2);

      // Gas cylinder
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.25, 12), metalMat);
      cylinder.position.set(0, 0.15, 0);
      chairGroup.add(cylinder);

      // 5-star base
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.025, 0.28), metalMat);
        arm.position.set(Math.sin(angle) * 0.14, 0.02, Math.cos(angle) * 0.14);
        arm.rotation.y = angle;
        chairGroup.add(arm);

        // Wheel
        const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.04, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(Math.sin(angle) * 0.28, 0.02, Math.cos(angle) * 0.28);
        chairGroup.add(wheel);
      }

      chairGroup.position.set(0, -0.35, 1.1); // Pushed back from desk
      chairGroup.rotation.y = 0.15; // Slightly angled
      scene.add(chairGroup);

      // === HEADPHONES on desk ===
      const headphonesMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });
      const headphonesAccent = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.4 }); // RGB accent

      const hpGroup = new THREE.Group();
      // Headband
      const headband = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.012, 8, 16, Math.PI), headphonesMat);
      headband.rotation.x = Math.PI / 2;
      headband.position.y = 0.04;
      hpGroup.add(headband);

      // Ear cups
      const earCup = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.03, 12), headphonesMat);
      earCup.rotation.z = Math.PI / 2;
      earCup.position.set(-0.08, 0, 0);
      hpGroup.add(earCup);
      const earCup2 = earCup.clone();
      earCup2.position.x = 0.08;
      hpGroup.add(earCup2);

      // RGB ring on cups
      const rgbRing = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 8, 16), headphonesAccent);
      rgbRing.rotation.y = Math.PI / 2;
      rgbRing.position.set(-0.095, 0, 0);
      hpGroup.add(rgbRing);
      const rgbRing2 = rgbRing.clone();
      rgbRing2.position.x = 0.095;
      hpGroup.add(rgbRing2);

      hpGroup.position.set(0.7, 0.58, 0.2);
      hpGroup.rotation.y = -0.5;
      hpGroup.rotation.x = Math.PI / 2; // Laying flat
      scene.add(hpGroup);

      // === ENERGY DRINK CANS ===
      const canMat1 = new THREE.MeshStandardMaterial({ color: 0x00ff88, metalness: 0.4, roughness: 0.3 }); // Monster green
      const canMat2 = new THREE.MeshStandardMaterial({ color: 0x0066ff, metalness: 0.4, roughness: 0.3 }); // Blue
      const canTop = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.2 });

      // Can 1 (standing)
      const can1 = new THREE.Group();
      const canBody1 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.1, 12), canMat1);
      can1.add(canBody1);
      const canTop1 = new THREE.Mesh(new THREE.CylinderGeometry(0.023, 0.025, 0.01, 12), canTop);
      canTop1.position.y = 0.05;
      can1.add(canTop1);
      can1.position.set(-0.85, 0.59, 0.35);
      scene.add(can1);

      // Can 2 (tipped over, empty)
      const can2 = new THREE.Group();
      const canBody2 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.1, 12), canMat2);
      can2.add(canBody2);
      const canTop2 = new THREE.Mesh(new THREE.CylinderGeometry(0.023, 0.025, 0.01, 12), canTop);
      canTop2.position.y = 0.05;
      can2.add(canTop2);
      can2.position.set(-0.75, 0.555, 0.45);
      can2.rotation.z = Math.PI / 2;
      can2.rotation.y = 0.3;
      scene.add(can2);

      // === STICKY NOTES ===
      const stickyYellow = new THREE.MeshStandardMaterial({ color: 0xffee55, roughness: 0.9 });
      const stickyPink = new THREE.MeshStandardMaterial({ color: 0xff88aa, roughness: 0.9 });
      const stickyBlue = new THREE.MeshStandardMaterial({ color: 0x55ccff, roughness: 0.9 });

      // Sticky note stack
      const sticky1 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.005, 0.12), stickyYellow);
      sticky1.position.set(-1.0, 0.555, -0.2);
      sticky1.rotation.y = 0.1;
      scene.add(sticky1);

      const sticky2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.003, 0.1), stickyPink);
      sticky2.position.set(-1.0, 0.56, -0.18);
      sticky2.rotation.y = -0.15;
      scene.add(sticky2);

      // Sticky on monitor
      const stickyOnMonitor = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.002), stickyBlue);
      stickyOnMonitor.position.set(0.52, 1.35, 0.31);
      stickyOnMonitor.rotation.y = -0.05;
      scene.add(stickyOnMonitor);

      // === BOOKS/NOTEBOOKS ===
      const bookMat1 = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.8 });
      const bookMat2 = new THREE.MeshStandardMaterial({ color: 0x882244, roughness: 0.8 });
      const pageMat = new THREE.MeshStandardMaterial({ color: 0xffffee, roughness: 0.9 });

      // Book stack
      const book1 = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.03, 0.25), bookMat1);
      book1.position.set(1.2, 0.555, -0.1);
      scene.add(book1);

      const book2 = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.025, 0.22), bookMat2);
      book2.position.set(1.2, 0.58, -0.1);
      book2.rotation.y = 0.15;
      scene.add(book2);

      // === PHONE on desk ===
      const phoneMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 });
      const phoneScreen = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1 });

      const phone = new THREE.Group();
      const phoneBody = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.008, 0.09), phoneMat);
      phone.add(phoneBody);
      const phoneScreenMesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.002, 0.08), phoneScreen);
      phoneScreenMesh.position.y = 0.005;
      phone.add(phoneScreenMesh);
      phone.position.set(0.35, 0.555, 0.5);
      phone.rotation.y = 0.8;
      scene.add(phone);

      // === USB/CABLE mess ===
      const cableMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });

      // Coiled cable
      for (let i = 0; i < 8; i++) {
        const segment = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.006, 0.04, 6), cableMat);
        segment.position.set(
          -0.6 + Math.sin(i * 0.8) * 0.03,
          0.54,
          0.55 + i * 0.015
        );
        segment.rotation.z = Math.PI / 2;
        segment.rotation.y = i * 0.3;
        scene.add(segment);
      }
    }

    // Mouse move - check if hovering screen
    function onMouseMove(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      const hint = document.getElementById('click-hint');
      if (intersects.length > 0) {
        hint.classList.add('visible');
        document.body.style.cursor = 'pointer';
      } else {
        hint.classList.remove('visible');
        document.body.style.cursor = 'grab';
      }
    }

    // Click - zoom into screen
    function onMouseClick(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      if (intersects.length > 0) {
        zoomIntoScreen();
      }
    }

    // Smooth zoom animation into screen
    function zoomIntoScreen() {
      isZooming = true;
      controls.enabled = false;
      playEnterSound(); // Play enter sound
      maybeStartHiss(); // Start background hiss

      // Hide UI
      document.getElementById('click-hint').classList.remove('visible');
      document.getElementById('controls-hint').classList.add('hidden');
      document.body.style.cursor = 'default';

      // Get current camera state
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const startTargetPos = { x: controls.target.x, y: controls.target.y, z: controls.target.z };

      const duration = 1500; // ms
      const startTime = Date.now();

      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function (ease-in-out)
        const eased = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        // Interpolate camera position
        camera.position.x = startCamPos.x + (endPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (endPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (endPos.z - startCamPos.z) * eased;

        // Interpolate target
        controls.target.x = startTargetPos.x + (endTarget.x - startTargetPos.x) * eased;
        controls.target.y = startTargetPos.y + (endTarget.y - startTargetPos.y) * eased;
        controls.target.z = startTargetPos.z + (endTarget.z - startTargetPos.z) * eased;

        camera.lookAt(controls.target);

        // Fade in screen glow at 50%
        if (progress > 0.5) {
          document.getElementById('screen-glow').classList.add('active');
        }

        // Fade out 3D scene at 80%
        if (progress > 0.8) {
          document.getElementById('scene-container').classList.add('fade-out');
        }

        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        } else {
          // Complete - show desktop
          setTimeout(() => {
            document.getElementById('desktop-fullscreen').classList.add('active');
            document.getElementById('back-btn').classList.add('active');
            document.getElementById('screen-glow').classList.remove('active');
            isZooming = false;
            isInDesktop = true;
            // Start the lofi music
            startMusic();
          }, 300);
        }
      }

      animateZoom();
    }

    // Exit desktop - zoom back out
    function exitDesktop() {
      document.getElementById('desktop-fullscreen').classList.remove('active');
      document.getElementById('back-btn').classList.remove('active');
      document.getElementById('scene-container').classList.remove('fade-out');

      // Reset camera position
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const duration = 800;
      const startTime = Date.now();

      function animateZoomOut() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // ease-out

        camera.position.x = startCamPos.x + (startPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (startPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (startPos.z - startCamPos.z) * eased;

        controls.target.x = endTarget.x + (startTarget.x - endTarget.x) * eased;
        controls.target.y = endTarget.y + (startTarget.y - endTarget.y) * eased;
        controls.target.z = endTarget.z + (startTarget.z - endTarget.z) * eased;

        camera.lookAt(controls.target);

        if (progress < 1) {
          requestAnimationFrame(animateZoomOut);
        } else {
          controls.enabled = true;
          isInDesktop = false;

          // Show UI again
          document.getElementById('controls-hint').classList.remove('hidden');
        }
      }

      animateZoomOut();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (!isZooming) {
        controls.update();
      }

      const time = Date.now() * 0.001;

      // Animate floating clouds
      clouds.forEach(cloud => {
        cloud.position.x += cloud.userData.speed;
        // Reset cloud when it goes too far
        if (cloud.position.x > 15) {
          cloud.position.x = -15;
        }
      });

      // Animate cats walking
      cats.forEach(cat => {
        cat.userData.walkTimer += 0.016;

        // Change direction occasionally
        if (Math.random() < 0.005) {
          cat.userData.direction += (Math.random() - 0.5) * Math.PI;
          cat.userData.isWalking = Math.random() > 0.3;
        }

        if (cat.userData.isWalking) {
          // Move cat
          cat.position.x += Math.cos(cat.userData.direction) * cat.userData.speed;
          cat.position.z += Math.sin(cat.userData.direction) * cat.userData.speed;

          // Face walking direction
          cat.rotation.y = -cat.userData.direction + Math.PI / 2;

          // Bobbing animation while walking
          cat.position.y = -0.35 + Math.sin(time * 10) * 0.01;

          // Keep cat in bounds
          if (Math.abs(cat.position.x) > 5) cat.userData.direction = Math.PI - cat.userData.direction;
          if (cat.position.z < 0.5 || cat.position.z > 5) cat.userData.direction = -cat.userData.direction;
        }
      });

      // Animate butterflies
      butterflies.forEach(bf => {
        const data = bf.userData;
        // Circular flying pattern
        bf.position.x += Math.sin(time * data.speed + data.phase) * 0.01;
        bf.position.z += Math.cos(time * data.speed + data.phase) * 0.01;
        bf.position.y = data.baseY + Math.sin(time * 2 + data.phase) * 0.15;

        // Face direction of movement
        bf.rotation.y = time * data.speed + data.phase;

        // Wing flapping
        if (bf.children[0]) {
          bf.children[0].rotation.y = Math.sin(time * 15 + data.wingPhase) * 0.5;
        }
        if (bf.children[1]) {
          bf.children[1].rotation.y = -Math.sin(time * 15 + data.wingPhase) * 0.5;
        }
      });

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize);

    // ESC to exit desktop
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isInDesktop) {
        exitDesktop();
      }
    });

    // Listen for messages from iframe (e.g., shutdown -> power on)
    window.addEventListener('message', (e) => {
      if (e.data === 'exitDesktop' && isInDesktop) {
        exitDesktop();
      }
    });

    // Initialize
    init();
  </script>
</body>
</html>
<!-- v2.1.0 - clean screen -->
