<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyle | 3D Desktop</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='r' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ff5f5f'/%3E%3Cstop offset='100%25' stop-color='%23cc0000'/%3E%3C/linearGradient%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2355ff55'/%3E%3Cstop offset='100%25' stop-color='%2300aa00'/%3E%3C/linearGradient%3E%3ClinearGradient id='b' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%235599ff'/%3E%3Cstop offset='100%25' stop-color='%230044cc'/%3E%3C/linearGradient%3E%3ClinearGradient id='y' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffee55'/%3E%3Cstop offset='100%25' stop-color='%23ccaa00'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x='2' y='2' width='13' height='13' rx='2' fill='url(%23r)'/%3E%3Crect x='17' y='2' width='13' height='13' rx='2' fill='url(%23g)'/%3E%3Crect x='2' y='17' width='13' height='13' rx='2' fill='url(%23b)'/%3E%3Crect x='17' y='17' width='13' height='13' rx='2' fill='url(%23y)'/%3E%3C/svg%3E">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Tahoma', sans-serif;
    }

    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      transition: opacity 0.5s ease;
    }

    #scene-container.fade-out {
      opacity: 0;
    }

    /* Controls hint */
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: #fff;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 12px 25px;
      border-radius: 8px;
      transition: opacity 0.3s;
      text-align: center;
    }

    .controls-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .controls-hint .main {
      font-size: 16px;
      margin-bottom: 5px;
    }

    .controls-hint .sub {
      font-size: 11px;
      color: #888;
    }

    /* Fullscreen desktop mode */
    .desktop-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .desktop-fullscreen.active {
      opacity: 1;
      pointer-events: auto;
    }

    .desktop-fullscreen iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Back button when in desktop mode */
    .back-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 1001;
      background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
      color: #fff;
      border: 2px solid #666;
      padding: 10px 20px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 5px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s, transform 0.2s;
      font-family: 'Tahoma', sans-serif;
    }

    .back-btn:hover {
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      transform: scale(1.05);
    }

    .back-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Screen glow overlay during transition */
    .screen-glow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, rgba(100,180,255,0.3) 0%, transparent 70%);
      z-index: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .screen-glow.active {
      opacity: 1;
    }

    /* Monitor highlight on hover */
    .click-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      background: rgba(0,100,200,0.8);
      padding: 15px 30px;
      border-radius: 10px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .click-hint.visible {
      opacity: 1;
    }
      /* Mobile overlay */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      z-index: 9999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }

    .mobile-overlay.show {
      display: flex;
    }

    .mobile-overlay h1 {
      color: #fff;
      font-size: 28px;
      margin-bottom: 10px;
    }

    .mobile-overlay p {
      color: #888;
      font-size: 14px;
      max-width: 300px;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .mobile-overlay .links {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 280px;
    }

    .mobile-overlay a {
      background: linear-gradient(180deg, #5b8def 0%, #3a6bc5 100%);
      color: #fff;
      text-decoration: none;
      padding: 14px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .mobile-overlay .skip-btn {
      background: transparent;
      border: 1px solid #444;
      color: #666;
      padding: 10px;
      margin-top: 20px;
      cursor: pointer;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      .mobile-overlay {
        display: flex;
      }
    }

    /* Music Toggle Button */
    .music-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      color: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background 0.2s;
    }
    .music-toggle:hover {
      background: rgba(0, 0, 0, 0.8);
    }
    .music-toggle.muted {
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <!-- Music Toggle Button -->
  <button class="music-toggle" id="music-toggle" onclick="toggleMusicBtn()">
    <span id="music-icon">üîä</span>
    <span id="music-text">Music</span>
  </button>
  <!-- Mobile Overlay -->
  <div class="mobile-overlay" id="mobile-overlay">
    <h1>Kyle Kumar</h1>
    <p>This portfolio is best experienced on desktop. It features a 3D interactive room with a Windows XP desktop simulation.</p>
    <div class="links">
      <a href="https://github.com/ergophobian" target="_blank">GitHub @ergophobian</a>
      <a href="https://tiktok.com/@ergophobian" target="_blank">TikTok @ergophobian</a>
      <a href="https://x.com/indefatigabile" target="_blank">X @indefatigabile</a>
    </div>
    <button class="skip-btn" onclick="document.getElementById('mobile-overlay').classList.remove('show');">
      Continue to desktop version anyway
    </button>
  </div>

  <!-- 3D Scene -->
  <div id="scene-container"></div>

  <!-- Controls hint -->
  <div class="controls-hint" id="controls-hint">
    <div class="main">Click the monitor to enter</div>
    <div class="sub">Drag to rotate ‚Ä¢ Scroll to zoom</div>
  </div>

  <!-- Click hint on monitor hover -->
  <div class="click-hint" id="click-hint">Click to Enter Desktop</div>

  <!-- Screen glow transition -->
  <div class="screen-glow" id="screen-glow"></div>

  <!-- Fullscreen desktop overlay -->
  <div class="desktop-fullscreen" id="desktop-fullscreen">
    <iframe src="desktop.html" id="desktop-iframe"></iframe>
  </div>

  <!-- Back button -->
  <button class="back-btn" id="back-btn" onclick="exitDesktop()">‚Üê Back to 3D View</button>

  <!-- Hidden YouTube Player for Music -->
  <div id="yt-player" style="position: absolute; left: -9999px; top: -9999px;"></div>

  <script>
    // ========== YOUTUBE MUSIC PLAYER ==========
    let ytPlayer = null;
    let isMusicPlaying = false;
    let musicInitialized = false;

    function onYouTubeIframeAPIReady() {
      ytPlayer = new YT.Player('yt-player', {
        height: '0',
        width: '0',
        videoId: 'RSFqIWudfq0', // Yabujin Flash Cassanova slowed
        playerVars: {
          autoplay: 0,
          loop: 1,
          playlist: 'RSFqIWudfq0',
          controls: 0,
          disablekb: 1,
          modestbranding: 1
        },
        events: {
          onReady: function(event) {
            ytPlayer.setVolume(30);
            musicInitialized = true;
          },
          onStateChange: function(event) {
            if (event.data === YT.PlayerState.ENDED) {
              ytPlayer.playVideo();
            }
          }
        }
      });
    }

    function startMusic() {
      if (musicInitialized && ytPlayer && !isMusicPlaying) {
        ytPlayer.playVideo();
        isMusicPlaying = true;
      }
    }

    function stopMusic() {
      if (ytPlayer && isMusicPlaying) {
        ytPlayer.pauseVideo();
        isMusicPlaying = false;
      }
    }

    function toggleMusicBtn() {
      const btn = document.getElementById('music-toggle');
      const icon = document.getElementById('music-icon');
      const text = document.getElementById('music-text');

      if (!musicInitialized || !ytPlayer) {
        return;
      }

      if (isMusicPlaying) {
        ytPlayer.pauseVideo();
        isMusicPlaying = false;
        icon.textContent = 'üîá';
        text.textContent = 'Muted';
        btn.classList.add('muted');
      } else {
        ytPlayer.playVideo();
        isMusicPlaying = true;
        icon.textContent = 'üîä';
        text.textContent = 'Music';
        btn.classList.remove('muted');
      }
    }
  </script>

  <script>
    // ============ SATISFYING SOUNDS ============
    let audioCtx = null;
    let hissNode = null;
    let hissGain = null;

    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    // Preload sounds
    const sounds = {
      keypress: new Audio('sounds/keypress.mp3'),
      enter: new Audio('sounds/enter.ogg'),
      click: new Audio('sounds/open-window.ogg')
    };

    // Set volumes
    sounds.keypress.volume = 0.4;
    sounds.enter.volume = 0.5;
    sounds.click.volume = 0.3;

    // Mechanical keyboard sound
    function playKeySound() {
      try {
        const sound = sounds.keypress.cloneNode();
        sound.volume = 0.3 + Math.random() * 0.2;
        sound.playbackRate = 0.95 + Math.random() * 0.1;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Click sound
    function playClickSound() {
      try {
        const sound = sounds.click.cloneNode();
        sound.volume = 0.3;
        sound.play().catch(() => {});
      } catch(e) {}
    }

    // Enter/confirmation sound
    function playEnterSound() {
      try {
        sounds.enter.currentTime = 0;
        sounds.enter.play().catch(() => {});
      } catch(e) {}
    }

    // Background hiss (CRT static)
    function startBackgroundHiss() {
      try {
        const ctx = getAudioCtx();
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        hissNode = ctx.createBufferSource();
        hissNode.buffer = noiseBuffer;
        hissNode.loop = true;

        // Filter to make it a softer hiss
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        hissGain = ctx.createGain();
        hissGain.gain.value = 0.015; // Very quiet

        hissNode.connect(filter);
        filter.connect(hissGain);
        hissGain.connect(ctx.destination);

        hissNode.start();
      } catch(e) {}
    }

    // Keyboard listener for mechanical sounds (only when in desktop mode)
    document.addEventListener('keydown', (e) => {
      if (!e.repeat && isInDesktop) playKeySound();
    });

    // Start hiss on first interaction (very subtle)
    let hissStarted = false;
    function maybeStartHiss() {
      if (!hissStarted) {
        hissStarted = true;
        startBackgroundHiss();
      }
    }

    // Three.js Scene
    let scene, camera, renderer, controls, composer, fxaaPass;
    let screenMesh; // Reference to clickable screen
    let screenLight; // Screen glow light (for flicker)
    let steamParticles = []; // Coffee steam particles
    let isZooming = false;
    let isInDesktop = false;

    // Camera animation
    const startPos = { x: 0, y: 2, z: 4 };
    const endPos = { x: 0, y: 1.15, z: 0.8 }; // Close to screen
    const startTarget = { x: 0, y: 1, z: 0 };
    const endTarget = { x: 0, y: 1.15, z: 0.36 }; // Screen position

    // Raycaster for click detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(startPos.x, startPos.y, startPos.z);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('scene-container').appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 1.5;
      controls.maxDistance = 8;
      controls.maxPolarAngle = Math.PI / 2;
      controls.target.set(startTarget.x, startTarget.y, startTarget.z);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Hemisphere light (sky blue top, warm brown bottom)
      const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3B2507, 0.4);
      scene.add(hemiLight);

      // Add slight point light on screen for glow effect
      screenLight = new THREE.PointLight(0x4488ff, 0.5, 3);
      screenLight.position.set(0, 1.15, 0.5);
      scene.add(screenLight);

      // Rim light behind monitor
      const rimLight = new THREE.PointLight(0x4488ff, 0.8, 4);
      rimLight.position.set(0, 1.5, -0.5);
      scene.add(rimLight);

      // Warm fill light
      const warmFill = new THREE.PointLight(0xffaa44, 0.3, 5);
      warmFill.position.set(-2, 2, 1);
      scene.add(warmFill);

      // Fog
      scene.fog = new THREE.FogExp2(0x87CEEB, 0.02);

      // Create scene objects
      createRoom();
      createDesk();
      createMonitor();
      createKeyboard();
      createMouse();
      createDecorations();
      createSleepingCharacter();
      createCats();

      // Mouse/click events
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      // Post-processing pipeline (with fallback to basic rendering)
      try {
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));

        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.3,  // strength (subtle)
          0.4,  // radius
          0.85  // threshold
        );
        composer.addPass(bloomPass);

        // FXAA anti-aliasing
        fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(fxaaPass);
      } catch (e) {
        console.warn('Post-processing failed, using basic renderer:', e);
        composer = null;
      }

      // Start animation
      animate();
    }

    // Floating clouds array
    let clouds = [];
    // Butterflies array
    let butterflies = [];

    function createRoom() {
      // WINDOWS XP BLISS - Authentic rolling green hills

      // Create smooth hilly terrain with higher resolution
      const terrainGeometry = new THREE.PlaneGeometry(60, 60, 128, 128);
      const vertices = terrainGeometry.attributes.position.array;

      // Smooth rolling hills - authentic XP Bliss feel
      for (let i = 0; i < vertices.length; i += 3) {
        const x = vertices[i];
        const y = vertices[i + 1];
        // Multiple sine waves for natural rolling hills
        const hill1 = Math.sin(x * 0.15) * Math.cos(y * 0.1) * 0.8;
        const hill2 = Math.sin(x * 0.08 + 0.5) * Math.sin(y * 0.12) * 0.5;
        const hill3 = Math.cos(x * 0.05 + y * 0.05) * 0.6;
        const micro = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.05; // Subtle micro detail
        vertices[i + 2] = hill1 + hill2 + hill3 + micro;
      }
      terrainGeometry.computeVertexNormals();

      // Create grass texture procedurally
      const grassCanvas = document.createElement('canvas');
      grassCanvas.width = 512;
      grassCanvas.height = 512;
      const grassCtx = grassCanvas.getContext('2d');

      // Base grass color
      grassCtx.fillStyle = '#3CB043';
      grassCtx.fillRect(0, 0, 512, 512);

      // Add grass blade details
      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const shade = Math.random() * 0.3;
        const green = Math.floor(160 + Math.random() * 60);
        grassCtx.fillStyle = `rgb(${30 + shade * 30}, ${green}, ${30 + shade * 20})`;
        grassCtx.fillRect(x, y, 2, 4 + Math.random() * 4);
      }

      // Add lighter highlights
      for (let i = 0; i < 500; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        grassCtx.fillStyle = 'rgba(100, 200, 100, 0.3)';
        grassCtx.fillRect(x, y, 3, 3);
      }

      const grassTexture = new THREE.CanvasTexture(grassCanvas);
      grassTexture.wrapS = THREE.RepeatWrapping;
      grassTexture.wrapT = THREE.RepeatWrapping;
      grassTexture.repeat.set(20, 20);

      const terrainMaterial = new THREE.MeshStandardMaterial({
        map: grassTexture,
        roughness: 0.9,
        metalness: 0,
        flatShading: false
      });
      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrain.rotation.x = -Math.PI / 2;
      terrain.position.y = -0.5;
      terrain.receiveShadow = true;
      scene.add(terrain);

      // Add grass tufts for texture
      createGrassTufts();

      // Add wildflowers
      createWildflowers();

      // === WINDOWS XP BLISS SKY ===
      scene.background = null;
      const skyGeometry = new THREE.SphereGeometry(80, 64, 64);
      const skyCanvas = document.createElement('canvas');
      skyCanvas.width = 2048;
      skyCanvas.height = 1024;
      const skyCtx = skyCanvas.getContext('2d');

      // Authentic XP Bliss sky gradient
      const skyGrad = skyCtx.createLinearGradient(0, 0, 0, skyCanvas.height);
      skyGrad.addColorStop(0, '#1565C0');     // Deep blue at zenith
      skyGrad.addColorStop(0.15, '#1E88E5');  // Rich blue
      skyGrad.addColorStop(0.3, '#42A5F5');   // Medium blue
      skyGrad.addColorStop(0.45, '#64B5F6');  // Lighter blue
      skyGrad.addColorStop(0.6, '#90CAF9');   // Light blue
      skyGrad.addColorStop(0.75, '#BBDEFB');  // Very light blue
      skyGrad.addColorStop(0.9, '#E3F2FD');   // Near white at horizon
      skyGrad.addColorStop(1, '#F5F9FF');     // White horizon
      skyCtx.fillStyle = skyGrad;
      skyCtx.fillRect(0, 0, skyCanvas.width, skyCanvas.height);

      // Draw fluffy cumulus clouds on sky texture
      function drawCloud(ctx, x, y, scale) {
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        const s = scale;
        // Multiple overlapping circles for fluffy appearance
        ctx.beginPath();
        ctx.arc(x, y, 35*s, 0, Math.PI * 2);
        ctx.arc(x + 30*s, y - 15*s, 30*s, 0, Math.PI * 2);
        ctx.arc(x + 55*s, y - 5*s, 32*s, 0, Math.PI * 2);
        ctx.arc(x + 80*s, y, 28*s, 0, Math.PI * 2);
        ctx.arc(x + 25*s, y + 12*s, 25*s, 0, Math.PI * 2);
        ctx.arc(x + 55*s, y + 15*s, 27*s, 0, Math.PI * 2);
        ctx.arc(x + 40*s, y - 8*s, 28*s, 0, Math.PI * 2);
        ctx.fill();

        // Subtle shadow on bottom of cloud
        ctx.fillStyle = 'rgba(200,210,220,0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 40*s, y + 20*s, 50*s, 12*s, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // Scattered clouds across the sky
      drawCloud(skyCtx, 150, 200, 1.2);
      drawCloud(skyCtx, 500, 150, 1.5);
      drawCloud(skyCtx, 900, 220, 1.1);
      drawCloud(skyCtx, 1300, 180, 1.4);
      drawCloud(skyCtx, 1700, 160, 1.3);
      drawCloud(skyCtx, 300, 350, 0.9);
      drawCloud(skyCtx, 750, 380, 1.0);
      drawCloud(skyCtx, 1150, 340, 1.1);
      drawCloud(skyCtx, 1550, 370, 0.95);
      drawCloud(skyCtx, 1900, 320, 1.2);

      const skyTexture = new THREE.CanvasTexture(skyCanvas);
      skyTexture.minFilter = THREE.LinearFilter;
      const skyMaterial = new THREE.MeshBasicMaterial({
        map: skyTexture,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // === 3D FLOATING CLOUDS - Big and prominent ===
      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.98,
        roughness: 1,
        metalness: 0,
        emissive: 0xffffff,
        emissiveIntensity: 0.1
      });

      // Create big fluffy clouds - closer and more visible
      const cloudConfigs = [
        { x: -8, y: 6, z: -5, scale: 2.5 },
        { x: 8, y: 7, z: -8, scale: 3 },
        { x: 0, y: 8, z: -12, scale: 4 },
        { x: -15, y: 5, z: -6, scale: 2 },
        { x: 15, y: 6, z: -10, scale: 2.5 },
        { x: -5, y: 9, z: -15, scale: 3 },
        { x: 12, y: 8, z: -18, scale: 3.5 },
        { x: -12, y: 7, z: -20, scale: 3 },
        { x: 5, y: 10, z: -25, scale: 4 },
        { x: -8, y: 11, z: -22, scale: 3.5 },
      ];

      cloudConfigs.forEach((config, i) => {
        const cloudGroup = new THREE.Group();
        const numPuffs = 6 + Math.floor(Math.random() * 5);

        for (let j = 0; j < numPuffs; j++) {
          const size = (0.4 + Math.random() * 0.5) * config.scale * 0.3;
          const puff = new THREE.Mesh(new THREE.SphereGeometry(size, 16, 16), cloudMaterial);
          puff.position.set(
            (j - numPuffs/2) * 0.4 * config.scale * 0.3 + Math.random() * 0.3,
            Math.random() * 0.3 * config.scale * 0.3,
            Math.random() * 0.4 * config.scale * 0.3 - 0.2
          );
          puff.scale.y = 0.5 + Math.random() * 0.3;
          cloudGroup.add(puff);
        }

        cloudGroup.position.set(config.x, config.y, config.z);
        cloudGroup.userData = {
          speed: 0.002 + Math.random() * 0.005,
          startX: config.x
        };
        clouds.push(cloudGroup);
        scene.add(cloudGroup);
      });

      // Create butterflies
      createButterflies();
    }

    function createGrassTufts() {
      // Scattered grass tufts for texture
      const grassMaterial = new THREE.MeshStandardMaterial({
        color: 0x2E7D32,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      for (let i = 0; i < 100; i++) {
        const tuft = new THREE.Group();
        // Each tuft has 3-5 blades
        const numBlades = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < numBlades; j++) {
          const blade = new THREE.Mesh(
            new THREE.ConeGeometry(0.015, 0.1 + Math.random() * 0.05, 4),
            grassMaterial
          );
          blade.position.set(
            (Math.random() - 0.5) * 0.05,
            0.04,
            (Math.random() - 0.5) * 0.05
          );
          blade.rotation.x = (Math.random() - 0.5) * 0.3;
          blade.rotation.z = (Math.random() - 0.5) * 0.3;
          tuft.add(blade);
        }
        tuft.position.set(
          (Math.random() - 0.5) * 15,
          -0.1,
          (Math.random() - 0.5) * 15
        );
        scene.add(tuft);
      }
    }

    function createWildflowers() {
      // Scattered wildflowers like in Windows XP Bliss
      const flowerColors = [0xFFEB3B, 0xFFFFFF, 0xFF7043, 0xE91E63, 0x9C27B0]; // Yellow, white, orange, pink, purple

      for (let i = 0; i < 50; i++) {
        const flower = new THREE.Group();
        const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];

        // Stem
        const stem = new THREE.Mesh(
          new THREE.CylinderGeometry(0.005, 0.005, 0.08 + Math.random() * 0.04, 6),
          new THREE.MeshStandardMaterial({ color: 0x33691E })
        );
        stem.position.y = 0.04;
        flower.add(stem);

        // Petals (simple)
        const petalMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
        for (let p = 0; p < 5; p++) {
          const petal = new THREE.Mesh(
            new THREE.SphereGeometry(0.015, 6, 6),
            petalMat
          );
          const angle = (p / 5) * Math.PI * 2;
          petal.position.set(
            Math.cos(angle) * 0.02,
            0.085,
            Math.sin(angle) * 0.02
          );
          petal.scale.y = 0.5;
          flower.add(petal);
        }

        // Center
        const center = new THREE.Mesh(
          new THREE.SphereGeometry(0.01, 6, 6),
          new THREE.MeshStandardMaterial({ color: 0xFFC107 })
        );
        center.position.y = 0.085;
        flower.add(center);

        flower.position.set(
          (Math.random() - 0.5) * 12,
          -0.1,
          (Math.random() - 0.5) * 12
        );
        scene.add(flower);
      }
    }

    function createButterflies() {
      // Animated butterflies floating around
      const butterflyColors = [0xFF9800, 0x2196F3, 0xFFEB3B, 0xE91E63];

      for (let i = 0; i < 6; i++) {
        const butterfly = new THREE.Group();
        const color = butterflyColors[Math.floor(Math.random() * butterflyColors.length)];
        const wingMat = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          side: THREE.DoubleSide
        });

        // Wings (simple triangular shapes)
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(0.03, 0.02);
        wingShape.lineTo(0.025, -0.02);
        wingShape.lineTo(0, 0);

        const wingGeo = new THREE.ShapeGeometry(wingShape);

        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.x = 0.005;
        butterfly.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.scale.x = -1;
        rightWing.position.x = -0.005;
        butterfly.add(rightWing);

        // Body
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.003, 0.002, 0.025, 6),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        body.rotation.x = Math.PI / 2;
        butterfly.add(body);

        butterfly.position.set(
          (Math.random() - 0.5) * 6,
          0.5 + Math.random() * 1.5,
          (Math.random() - 0.5) * 6
        );

        butterfly.userData = {
          baseY: butterfly.position.y,
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 0.5,
          radius: 0.5 + Math.random() * 1,
          wingPhase: Math.random() * Math.PI * 2
        };

        butterflies.push(butterfly);
        scene.add(butterfly);
      }
    }

    // Cats array
    let cats = [];

    function createCats() {
      const catColors = [0xFFFFFF, 0x333333, 0xFFAA00, 0x888888]; // White, black, orange, gray

      for (let i = 0; i < 3; i++) {
        const catGroup = new THREE.Group();
        const catColor = catColors[Math.floor(Math.random() * catColors.length)];
        const catMaterial = new THREE.MeshStandardMaterial({ color: catColor, roughness: 0.9 });

        // Body (using stretched sphere since CapsuleGeometry not in r128)
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), catMaterial);
        body.scale.set(1.5, 0.8, 0.8);
        body.position.y = 0.15;
        catGroup.add(body);

        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 8, 8), catMaterial);
        head.position.set(0.18, 0.18, 0);
        catGroup.add(head);

        // Ears
        const earGeo = new THREE.ConeGeometry(0.04, 0.08, 4);
        const ear1 = new THREE.Mesh(earGeo, catMaterial);
        ear1.position.set(0.22, 0.32, 0.05);
        catGroup.add(ear1);
        const ear2 = new THREE.Mesh(earGeo, catMaterial);
        ear2.position.set(0.22, 0.32, -0.05);
        catGroup.add(ear2);

        // Tail
        const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.015, 0.22, 8), catMaterial);
        tail.position.set(-0.22, 0.22, 0);
        tail.rotation.z = Math.PI / 4;
        catGroup.add(tail);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.12, 8);
        [[-0.08, 0.06, 0.06], [-0.08, 0.06, -0.06], [0.08, 0.06, 0.06], [0.08, 0.06, -0.06]].forEach(pos => {
          const leg = new THREE.Mesh(legGeo, catMaterial);
          leg.position.set(...pos);
          catGroup.add(leg);
        });

        // Position cat on the terrain (raised well above ground)
        catGroup.position.set(
          (Math.random() - 0.5) * 6,
          0.1,
          1 + Math.random() * 3
        );

        catGroup.userData = {
          speed: 0.005 + Math.random() * 0.01,
          direction: Math.random() * Math.PI * 2,
          walkTimer: 0,
          isWalking: true
        };

        cats.push(catGroup);
        scene.add(catGroup);
      }
    }

    function createDesk() {
      // Procedural wood grain texture
      const woodCanvas = document.createElement('canvas');
      woodCanvas.width = 256; woodCanvas.height = 256;
      const wCtx = woodCanvas.getContext('2d');
      wCtx.fillStyle = '#5C4033';
      wCtx.fillRect(0, 0, 256, 256);
      // Add wood grain lines
      for (let i = 0; i < 40; i++) {
        wCtx.strokeStyle = `rgba(80, 50, 30, ${0.1 + Math.random() * 0.15})`;
        wCtx.lineWidth = 1 + Math.random() * 2;
        wCtx.beginPath();
        const y = i * 6 + Math.random() * 4;
        wCtx.moveTo(0, y);
        wCtx.bezierCurveTo(64, y + Math.random()*4, 192, y - Math.random()*4, 256, y + Math.random()*3);
        wCtx.stroke();
      }
      const woodTexture = new THREE.CanvasTexture(woodCanvas);

      const deskMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0x5C4033,
        roughness: 0.7
      });

      // Desk top
      const deskTopGeometry = new THREE.BoxGeometry(3, 0.08, 1.5);
      const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
      deskTop.position.set(0, 0.5, 0);
      deskTop.castShadow = true;
      deskTop.receiveShadow = true;
      scene.add(deskTop);

      // Desk legs
      const legGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
      [[-1.4, 0, -0.65], [1.4, 0, -0.65], [-1.4, 0, 0.65], [1.4, 0, 0.65]].forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, deskMaterial);
        leg.position.set(...pos);
        leg.castShadow = true;
        scene.add(leg);
      });
    }

    function createMonitor() {
      // Classic CRT monitor - improved quality
      const monitorColor = 0xD4C5A9; // Beige/off-white classic color
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: monitorColor, roughness: 0.6, metalness: 0.05 });
      const darkPlastic = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });

      // Main monitor body (CRT bulk with beveled appearance)
      const monitorGroup = new THREE.Group();

      // Main body
      const bodyGeometry = new THREE.BoxGeometry(1.15, 0.95, 0.95);
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0, 0);
      body.castShadow = true;
      monitorGroup.add(body);

      // Front face panel (slightly inset)
      const frontPanel = new THREE.Mesh(
        new THREE.BoxGeometry(1.1, 0.9, 0.05),
        bodyMaterial
      );
      frontPanel.position.set(0, 0.02, 0.48);
      monitorGroup.add(frontPanel);

      // Screen bezel (dark frame around screen)
      const bezelOuter = new THREE.Mesh(
        new THREE.BoxGeometry(0.95, 0.75, 0.03),
        darkPlastic
      );
      bezelOuter.position.set(0, 0.05, 0.52);
      monitorGroup.add(bezelOuter);

      // Inner bezel lip (slight depth)
      const bezelInner = new THREE.Mesh(
        new THREE.BoxGeometry(0.88, 0.68, 0.02),
        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 })
      );
      bezelInner.position.set(0, 0.05, 0.535);
      monitorGroup.add(bezelInner);

      // Ventilation slots on sides
      const ventMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 });
      for (let i = 0; i < 6; i++) {
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.08, 0.4), ventMat);
        vent.position.set(0.58, 0.25 - i * 0.1, 0);
        monitorGroup.add(vent);
        const vent2 = vent.clone();
        vent2.position.x = -0.58;
        monitorGroup.add(vent2);
      }

      // Bottom control panel area
      const controlPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.08, 0.05),
        new THREE.MeshStandardMaterial({ color: 0xc0b8a0, roughness: 0.5 })
      );
      controlPanel.position.set(0, -0.35, 0.52);
      monitorGroup.add(controlPanel);

      // Control buttons
      const buttonMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.3 });
      for (let i = 0; i < 4; i++) {
        const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.02, 8), buttonMat);
        btn.rotation.x = Math.PI / 2;
        btn.position.set(-0.15 + i * 0.08, -0.35, 0.54);
        monitorGroup.add(btn);
      }

      // Power LED
      const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
      const led = new THREE.Mesh(new THREE.CircleGeometry(0.012, 12), ledMaterial);
      led.position.set(0.22, -0.35, 0.545);
      monitorGroup.add(led);

      // Brand logo area (subtle indent)
      const logoArea = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.025, 0.01),
        new THREE.MeshStandardMaterial({ color: 0xb8b0a0, roughness: 0.3 })
      );
      logoArea.position.set(0, -0.42, 0.52);
      monitorGroup.add(logoArea);

      monitorGroup.position.set(0, 1.1, -0.18);
      scene.add(monitorGroup);

      // === SCREEN - Clean XP Bliss display ===
      const screenGeometry = new THREE.PlaneGeometry(0.82, 0.62, 1, 1);

      // Create clean XP desktop texture (no vignette to avoid moir√©)
      const canvas = document.createElement('canvas');
      canvas.width = 820;  // Match aspect ratio to geometry to avoid stretching
      canvas.height = 620;
      const ctx = canvas.getContext('2d');

      // XP Bliss background - authentic colors
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1E5BC6');    // Deep blue
      gradient.addColorStop(0.3, '#3A7BD5');
      gradient.addColorStop(0.6, '#5A9BD5');
      gradient.addColorStop(1, '#8ECAE6');    // Light blue at horizon
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Rolling hills - multiple layers for depth
      // Back hill
      ctx.fillStyle = '#2D8F38';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(160, 350, 320, 270, 480, 330);
      ctx.bezierCurveTo(640, 390, 720, 300, 820, 360);
      ctx.lineTo(820, canvas.height);
      ctx.fill();

      // Middle hill
      ctx.fillStyle = '#3CB043';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(120, 380, 280, 320, 410, 380);
      ctx.bezierCurveTo(560, 440, 680, 340, 820, 400);
      ctx.lineTo(820, canvas.height);
      ctx.fill();

      // Front hill - brightest
      ctx.fillStyle = '#4ADE54';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.bezierCurveTo(205, 470, 410, 420, 615, 470);
      ctx.bezierCurveTo(720, 500, 780, 450, 820, canvas.height - 80);
      ctx.lineTo(820, canvas.height);
      ctx.fill();

      // Fluffy clouds - drawn with solid fills
      ctx.fillStyle = '#ffffff';
      const cloudPositions = [
        [100, 80, 36], [220, 110, 44], [360, 72, 40],
        [500, 100, 38], [620, 80, 42], [740, 120, 36]
      ];
      cloudPositions.forEach(([x, y, r]) => {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.arc(x + r*0.6, y - r*0.35, r*0.75, 0, Math.PI * 2);
        ctx.arc(x + r*1.1, y - r*0.1, r*0.85, 0, Math.PI * 2);
        ctx.arc(x + r*1.5, y + r*0.1, r*0.7, 0, Math.PI * 2);
        ctx.arc(x + r*0.3, y + r*0.25, r*0.6, 0, Math.PI * 2);
        ctx.fill();
      });

      // Desktop icons (simplified, no shadows that cause artifacts)
      const icons = [
        { name: 'My Computer', y: 40 },
        { name: 'Recycle Bin', y: 105 },
        { name: 'My Documents', y: 170 }
      ];
      icons.forEach(icon => {
        // Icon box
        ctx.fillStyle = '#e0e8f0';
        ctx.fillRect(24, icon.y, 38, 38);
        // Icon text
        ctx.fillStyle = '#ffffff';
        ctx.font = '9px Tahoma, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(icon.name, 43, icon.y + 52);
      });
      ctx.textAlign = 'left';

      // Taskbar - solid colors
      ctx.fillStyle = '#245ED8';
      ctx.fillRect(0, canvas.height - 32, canvas.width, 32);

      // Taskbar top edge highlight
      ctx.fillStyle = '#3168DC';
      ctx.fillRect(0, canvas.height - 32, canvas.width, 3);

      // Start button
      ctx.fillStyle = '#2D8F2D';
      ctx.fillRect(2, canvas.height - 30, 80, 26);

      // Start button highlight
      ctx.fillStyle = '#3C9C3C';
      ctx.fillRect(2, canvas.height - 30, 80, 2);

      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold italic 13px Tahoma, sans-serif';
      ctx.fillText('start', 28, canvas.height - 13);

      // Clock in system tray
      ctx.fillStyle = '#ffffff';
      ctx.font = '9px Tahoma, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText('4:20 PM', canvas.width - 8, canvas.height - 12);

      // Create texture with settings to prevent moir√©/aliasing
      const screenTexture = new THREE.CanvasTexture(canvas);
      screenTexture.minFilter = THREE.LinearFilter;
      screenTexture.magFilter = THREE.LinearFilter;
      screenTexture.generateMipmaps = false; // Disable mipmaps to prevent artifacts

      const screenMaterial = new THREE.MeshBasicMaterial({
        map: screenTexture
      });

      screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
      screenMesh.position.set(0, 1.15, 0.37);
      screenMesh.name = 'screen';
      scene.add(screenMesh);

      // Monitor stand (neck)
      const standNeck = new THREE.Mesh(
        new THREE.BoxGeometry(0.35, 0.12, 0.45),
        bodyMaterial
      );
      standNeck.position.set(0, 0.58, -0.15);
      standNeck.castShadow = true;
      scene.add(standNeck);

      // Monitor base (wider foot)
      const baseGeometry = new THREE.BoxGeometry(0.55, 0.04, 0.35);
      const base = new THREE.Mesh(baseGeometry, bodyMaterial);
      base.position.set(0, 0.52, -0.08);
      base.castShadow = true;
      scene.add(base);

      // Tilt adjustment mechanism
      const tiltMech = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.06, 0.02, 16),
        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.3 })
      );
      tiltMech.rotation.x = Math.PI / 2;
      tiltMech.position.set(0, 0.64, -0.2);
      scene.add(tiltMech);
    }

    function createKeyboard() {
      const kbMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });
      const keyMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4 });

      const kbGeometry = new THREE.BoxGeometry(0.6, 0.03, 0.2);
      const kb = new THREE.Mesh(kbGeometry, kbMaterial);
      kb.position.set(0, 0.56, 0.45);
      kb.castShadow = true;
      scene.add(kb);

      // Keys
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 12; col++) {
          const keyGeometry = new THREE.BoxGeometry(0.04, 0.015, 0.04);
          const key = new THREE.Mesh(keyGeometry, keyMaterial);
          key.position.set(-0.25 + col * 0.045, 0.58, 0.38 + row * 0.045);
          scene.add(key);
        }
      }
    }

    function createMouse() {
      const mouseMaterial = new THREE.MeshStandardMaterial({ color: 0xD4C5A9, roughness: 0.5 });

      const mouseGeometry = new THREE.SphereGeometry(0.04, 12, 8);
      const mouseMeshObj = new THREE.Mesh(mouseGeometry, mouseMaterial);
      mouseMeshObj.scale.set(0.8, 0.3, 1.2);
      mouseMeshObj.position.set(0.5, 0.55, 0.45);
      mouseMeshObj.castShadow = true;
      scene.add(mouseMeshObj);

      // Cable
      const cableGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8);
      const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const cable = new THREE.Mesh(cableGeometry, cableMaterial);
      cable.position.set(0.5, 0.54, 0.25);
      cable.rotation.x = Math.PI / 2;
      scene.add(cable);
    }

    function createSleepingCharacter() {
      // Sleeping person at the desk - Kyle asleep on the keyboard
      const charGroup = new THREE.Group();

      const skinMat = new THREE.MeshStandardMaterial({ color: 0xf4c5a0, roughness: 0.8 });
      const hairMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 });
      const shirtMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.7 });
      const pantsMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.7 });

      // Torso (leaning forward, chest resting near desk edge)
      const torso = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.22), shirtMat);
      torso.position.set(0, 0.72, 0.7);
      torso.rotation.x = 0.6; // Leaning forward onto desk
      charGroup.add(torso);

      // Head (face down on the desk, resting on arms)
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 10), skinMat);
      head.scale.set(1, 0.9, 1);
      head.position.set(0, 0.6, 0.42);
      charGroup.add(head);

      // Hair on top/back of head
      const hair = new THREE.Mesh(new THREE.SphereGeometry(0.105, 10, 10, 0, Math.PI * 2, 0, Math.PI * 0.6), hairMat);
      hair.position.set(0, 0.63, 0.42);
      charGroup.add(hair);

      // Left arm (stretched forward on desk)
      const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 0.32), shirtMat);
      leftArm.position.set(-0.18, 0.56, 0.45);
      leftArm.rotation.x = 0.1;
      charGroup.add(leftArm);

      // Right arm (stretched forward on desk, slightly different angle)
      const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 0.32), shirtMat);
      rightArm.position.set(0.18, 0.56, 0.45);
      rightArm.rotation.x = 0.1;
      rightArm.rotation.y = -0.05;
      charGroup.add(rightArm);

      // Left hand
      const leftHand = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), skinMat);
      leftHand.scale.set(1.2, 0.6, 1.3);
      leftHand.position.set(-0.18, 0.56, 0.28);
      charGroup.add(leftHand);

      // Right hand
      const rightHand = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), skinMat);
      rightHand.scale.set(1.2, 0.6, 1.3);
      rightHand.position.set(0.18, 0.56, 0.28);
      charGroup.add(rightHand);

      // Upper legs (seated in chair, slightly visible)
      const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.35), pantsMat);
      leftLeg.position.set(-0.1, 0.42, 0.85);
      leftLeg.rotation.x = 0.1;
      charGroup.add(leftLeg);

      const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.35), pantsMat);
      rightLeg.position.set(0.1, 0.42, 0.85);
      rightLeg.rotation.x = 0.1;
      charGroup.add(rightLeg);

      // Lower legs (hanging under desk)
      const leftShin = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.1), pantsMat);
      leftShin.position.set(-0.1, 0.22, 0.95);
      charGroup.add(leftShin);

      const rightShin = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.1), pantsMat);
      rightShin.position.set(0.1, 0.22, 0.95);
      charGroup.add(rightShin);

      // Shoes
      const shoeMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });
      const leftShoe = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 0.15), shoeMat);
      leftShoe.position.set(-0.1, 0.07, 0.98);
      charGroup.add(leftShoe);

      const rightShoe = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 0.15), shoeMat);
      rightShoe.position.set(0.1, 0.07, 0.98);
      charGroup.add(rightShoe);

      // Subtle breathing animation (slight rise/fall of torso)
      charGroup.userData = { breathPhase: 0 };
      charGroup.name = 'sleepingCharacter';

      scene.add(charGroup);

      // Floating "Z" particles for sleeping effect
      const zCanvas = document.createElement('canvas');
      zCanvas.width = 64; zCanvas.height = 64;
      const zCtx = zCanvas.getContext('2d');
      zCtx.fillStyle = '#ffffff';
      zCtx.font = 'bold 48px Arial';
      zCtx.textAlign = 'center';
      zCtx.fillText('Z', 32, 50);
      const zTexture = new THREE.CanvasTexture(zCanvas);

      const zMat = new THREE.SpriteMaterial({ map: zTexture, transparent: true, opacity: 0.6 });
      for (let i = 0; i < 3; i++) {
        const z = new THREE.Sprite(zMat.clone());
        z.scale.set(0.06 + i * 0.02, 0.06 + i * 0.02, 1);
        z.position.set(0.15, 0.75 + i * 0.12, 0.35);
        z.userData = { baseY: 0.75 + i * 0.12, phase: i * 1.2, idx: i };
        z.name = 'zzz_' + i;
        scene.add(z);
      }
    }

    function createDecorations() {
      // Plant
      const potMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const potGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 8);
      const pot = new THREE.Mesh(potGeometry, potMaterial);
      pot.position.set(-1.2, 0.62, 0);
      pot.castShadow = true;
      scene.add(pot);

      const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
      for (let i = 0; i < 5; i++) {
        const leafGeometry = new THREE.ConeGeometry(0.03, 0.2, 4);
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(-1.2 + Math.cos(angle) * 0.05, 0.8, Math.sin(angle) * 0.05);
        leaf.rotation.x = 0.3 * Math.cos(angle);
        leaf.rotation.z = 0.3 * Math.sin(angle);
        scene.add(leaf);
      }

      // Coffee mug (rounder with handle)
      const mugMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3 });
      const mugGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.1, 24);
      const mug = new THREE.Mesh(mugGeometry, mugMaterial);
      mug.position.set(1.1, 0.59, 0.3);
      mug.castShadow = true;
      scene.add(mug);

      // Mug handle (torus)
      const handle = new THREE.Mesh(
        new THREE.TorusGeometry(0.025, 0.006, 8, 12, Math.PI),
        mugMaterial
      );
      handle.rotation.y = Math.PI / 2;
      handle.position.set(1.15, 0.59, 0.3);
      scene.add(handle);

      const coffeeGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 24);
      const coffeeMaterial = new THREE.MeshStandardMaterial({ color: 0x3C1810, roughness: 0.2 });
      const coffee = new THREE.Mesh(coffeeGeometry, coffeeMaterial);
      coffee.position.set(1.1, 0.63, 0.3);
      scene.add(coffee);

      // Steam particles above coffee
      const steamMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
      for (let i = 0; i < 8; i++) {
        const steam = new THREE.Mesh(new THREE.SphereGeometry(0.008, 6, 6), steamMat.clone());
        steam.position.set(1.1 + (Math.random()-0.5)*0.03, 0.65 + Math.random()*0.1, 0.3 + (Math.random()-0.5)*0.03);
        steam.userData = { baseY: steam.position.y, phase: Math.random() * Math.PI * 2, speed: 0.3 + Math.random() * 0.3 };
        steamParticles.push(steam);
        scene.add(steam);
      }

      // Add workspace details (gaming chair, headphones, energy drinks, etc.)
      createWorkspaceDetails();
    }

    function createWorkspaceDetails() {
      // Developer workspace accessories that look great in low-poly style

      // === GAMING CHAIR (empty, slightly pushed back) ===
      const chairGroup = new THREE.Group();
      const chairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2, metalness: 0.1 });
      const chairRed = new THREE.MeshStandardMaterial({ color: 0xff2222, roughness: 0.3 }); // Vibrant red accent
      const metalMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.2 });

      // Seat cushion
      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.08, 0.45), chairMat);
      seat.position.y = 0.35;
      chairGroup.add(seat);

      // Seat side bolsters
      const seatBolster = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.4), chairRed);
      seatBolster.position.set(-0.22, 0.38, 0);
      chairGroup.add(seatBolster);
      const seatBolster2 = seatBolster.clone();
      seatBolster2.position.x = 0.22;
      chairGroup.add(seatBolster2);

      // Back rest
      const backRest = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.55, 0.08), chairMat);
      backRest.position.set(0, 0.65, -0.22);
      backRest.rotation.x = 0.1;
      chairGroup.add(backRest);

      // Back bolsters (racing style)
      const backBolster = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.45, 0.1), chairRed);
      backBolster.position.set(-0.2, 0.62, -0.2);
      backBolster.rotation.x = 0.1;
      chairGroup.add(backBolster);
      const backBolster2 = backBolster.clone();
      backBolster2.position.x = 0.2;
      chairGroup.add(backBolster2);

      // Headrest
      const headrest = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.12, 0.08), chairMat);
      headrest.position.set(0, 0.98, -0.22);
      chairGroup.add(headrest);

      // Armrests
      const armrestBase = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.15, 0.04), metalMat);
      armrestBase.position.set(-0.28, 0.42, 0.05);
      chairGroup.add(armrestBase);
      const armrestTop = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.2), chairMat);
      armrestTop.position.set(-0.28, 0.5, 0.05);
      chairGroup.add(armrestTop);
      const armrestBase2 = armrestBase.clone();
      armrestBase2.position.x = 0.28;
      chairGroup.add(armrestBase2);
      const armrestTop2 = armrestTop.clone();
      armrestTop2.position.x = 0.28;
      chairGroup.add(armrestTop2);

      // Gas cylinder
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.25, 12), metalMat);
      cylinder.position.set(0, 0.15, 0);
      chairGroup.add(cylinder);

      // 5-star base
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.025, 0.28), metalMat);
        arm.position.set(Math.sin(angle) * 0.14, 0.02, Math.cos(angle) * 0.14);
        arm.rotation.y = angle;
        chairGroup.add(arm);

        // Wheel
        const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.04, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(Math.sin(angle) * 0.28, 0.02, Math.cos(angle) * 0.28);
        chairGroup.add(wheel);
      }

      chairGroup.position.set(0, 0.15, 1.1); // Pushed back from desk, raised well above terrain
      chairGroup.rotation.y = 0.15; // Slightly angled
      scene.add(chairGroup);

      // === HEADPHONES on desk ===
      const headphonesMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });
      const headphonesAccent = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.4 }); // RGB accent

      const hpGroup = new THREE.Group();
      // Headband
      const headband = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.012, 8, 16, Math.PI), headphonesMat);
      headband.rotation.x = Math.PI / 2;
      headband.position.y = 0.04;
      hpGroup.add(headband);

      // Ear cups
      const earCup = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.03, 12), headphonesMat);
      earCup.rotation.z = Math.PI / 2;
      earCup.position.set(-0.08, 0, 0);
      hpGroup.add(earCup);
      const earCup2 = earCup.clone();
      earCup2.position.x = 0.08;
      hpGroup.add(earCup2);

      // RGB ring on cups
      const rgbRing = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 8, 16), headphonesAccent);
      rgbRing.rotation.y = Math.PI / 2;
      rgbRing.position.set(-0.095, 0, 0);
      hpGroup.add(rgbRing);
      const rgbRing2 = rgbRing.clone();
      rgbRing2.position.x = 0.095;
      hpGroup.add(rgbRing2);

      hpGroup.position.set(0.7, 0.58, 0.2);
      hpGroup.rotation.y = -0.5;
      hpGroup.rotation.x = Math.PI / 2; // Laying flat
      scene.add(hpGroup);

      // === ENERGY DRINK CANS ===
      const canMat1 = new THREE.MeshStandardMaterial({ color: 0x00ff88, metalness: 0.6, roughness: 0.15 }); // Monster green
      const canMat2 = new THREE.MeshStandardMaterial({ color: 0x0066ff, metalness: 0.6, roughness: 0.15 }); // Blue
      const canTop = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.15 });

      // Can 1 (standing)
      const can1 = new THREE.Group();
      const canBody1 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.1, 12), canMat1);
      can1.add(canBody1);
      const canTop1 = new THREE.Mesh(new THREE.CylinderGeometry(0.023, 0.025, 0.01, 12), canTop);
      canTop1.position.y = 0.05;
      can1.add(canTop1);
      can1.position.set(-0.85, 0.59, 0.35);
      scene.add(can1);

      // Can 2 (tipped over, empty)
      const can2 = new THREE.Group();
      const canBody2 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.1, 12), canMat2);
      can2.add(canBody2);
      const canTop2 = new THREE.Mesh(new THREE.CylinderGeometry(0.023, 0.025, 0.01, 12), canTop);
      canTop2.position.y = 0.05;
      can2.add(canTop2);
      can2.position.set(-0.75, 0.555, 0.45);
      can2.rotation.z = Math.PI / 2;
      can2.rotation.y = 0.3;
      scene.add(can2);

      // === STICKY NOTES ===
      const stickyYellow = new THREE.MeshStandardMaterial({ color: 0xffee55, roughness: 0.9 });
      const stickyPink = new THREE.MeshStandardMaterial({ color: 0xff88aa, roughness: 0.9 });
      const stickyBlue = new THREE.MeshStandardMaterial({ color: 0x55ccff, roughness: 0.9 });

      // Sticky note stack
      const sticky1 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.005, 0.12), stickyYellow);
      sticky1.position.set(-1.0, 0.555, -0.2);
      sticky1.rotation.y = 0.1;
      scene.add(sticky1);

      const sticky2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.003, 0.1), stickyPink);
      sticky2.position.set(-1.0, 0.56, -0.18);
      sticky2.rotation.y = -0.15;
      scene.add(sticky2);

      // Sticky on monitor
      const stickyOnMonitor = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.002), stickyBlue);
      stickyOnMonitor.position.set(0.52, 1.35, 0.31);
      stickyOnMonitor.rotation.y = -0.05;
      scene.add(stickyOnMonitor);

      // === BOOKS/NOTEBOOKS ===
      const bookMat1 = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.8 });
      const bookMat2 = new THREE.MeshStandardMaterial({ color: 0x882244, roughness: 0.8 });
      const pageMat = new THREE.MeshStandardMaterial({ color: 0xffffee, roughness: 0.9 });

      // Book stack
      const book1 = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.03, 0.25), bookMat1);
      book1.position.set(1.2, 0.555, -0.1);
      scene.add(book1);

      const book2 = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.025, 0.22), bookMat2);
      book2.position.set(1.2, 0.58, -0.1);
      book2.rotation.y = 0.15;
      scene.add(book2);

      // === PHONE on desk ===
      const phoneMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 });
      const phoneScreen = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1 });

      const phone = new THREE.Group();
      const phoneBody = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.008, 0.09), phoneMat);
      phone.add(phoneBody);
      const phoneScreenMesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.002, 0.08), phoneScreen);
      phoneScreenMesh.position.y = 0.005;
      phone.add(phoneScreenMesh);
      phone.position.set(0.35, 0.555, 0.5);
      phone.rotation.y = 0.8;
      scene.add(phone);

      // === USB/CABLE mess ===
      const cableMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });

      // Coiled cable
      for (let i = 0; i < 8; i++) {
        const segment = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.006, 0.04, 6), cableMat);
        segment.position.set(
          -0.6 + Math.sin(i * 0.8) * 0.03,
          0.54,
          0.55 + i * 0.015
        );
        segment.rotation.z = Math.PI / 2;
        segment.rotation.y = i * 0.3;
        scene.add(segment);
      }
    }

    // Mouse move - check if hovering screen
    function onMouseMove(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      const hint = document.getElementById('click-hint');
      if (intersects.length > 0) {
        hint.classList.add('visible');
        document.body.style.cursor = 'pointer';
      } else {
        hint.classList.remove('visible');
        document.body.style.cursor = 'grab';
      }
    }

    // Click - zoom into screen
    function onMouseClick(event) {
      if (isZooming || isInDesktop) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(screenMesh);

      if (intersects.length > 0) {
        zoomIntoScreen();
      }
    }

    // Smooth zoom animation into screen
    function zoomIntoScreen() {
      isZooming = true;
      controls.enabled = false;
      playEnterSound(); // Play enter sound
      maybeStartHiss(); // Start background hiss

      // Hide UI
      document.getElementById('click-hint').classList.remove('visible');
      document.getElementById('controls-hint').classList.add('hidden');
      document.body.style.cursor = 'default';

      // Get current camera state
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const startTargetPos = { x: controls.target.x, y: controls.target.y, z: controls.target.z };

      const duration = 1500; // ms
      const startTime = Date.now();

      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function (ease-in-out)
        const eased = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        // Interpolate camera position
        camera.position.x = startCamPos.x + (endPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (endPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (endPos.z - startCamPos.z) * eased;

        // Interpolate target
        controls.target.x = startTargetPos.x + (endTarget.x - startTargetPos.x) * eased;
        controls.target.y = startTargetPos.y + (endTarget.y - startTargetPos.y) * eased;
        controls.target.z = startTargetPos.z + (endTarget.z - startTargetPos.z) * eased;

        camera.lookAt(controls.target);

        // Fade in screen glow at 50%
        if (progress > 0.5) {
          document.getElementById('screen-glow').classList.add('active');
        }

        // Fade out 3D scene at 80%
        if (progress > 0.8) {
          document.getElementById('scene-container').classList.add('fade-out');
        }

        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        } else {
          // Complete - show desktop
          setTimeout(() => {
            document.getElementById('desktop-fullscreen').classList.add('active');
            document.getElementById('back-btn').classList.add('active');
            document.getElementById('screen-glow').classList.remove('active');
            isZooming = false;
            isInDesktop = true;
            // Start the lofi music
            startMusic();
          }, 300);
        }
      }

      animateZoom();
    }

    // Exit desktop - zoom back out
    function exitDesktop() {
      document.getElementById('desktop-fullscreen').classList.remove('active');
      document.getElementById('back-btn').classList.remove('active');
      document.getElementById('scene-container').classList.remove('fade-out');

      // Reset camera position
      const startCamPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
      const duration = 800;
      const startTime = Date.now();

      function animateZoomOut() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // ease-out

        camera.position.x = startCamPos.x + (startPos.x - startCamPos.x) * eased;
        camera.position.y = startCamPos.y + (startPos.y - startCamPos.y) * eased;
        camera.position.z = startCamPos.z + (startPos.z - startCamPos.z) * eased;

        controls.target.x = endTarget.x + (startTarget.x - endTarget.x) * eased;
        controls.target.y = endTarget.y + (startTarget.y - endTarget.y) * eased;
        controls.target.z = endTarget.z + (startTarget.z - endTarget.z) * eased;

        camera.lookAt(controls.target);

        if (progress < 1) {
          requestAnimationFrame(animateZoomOut);
        } else {
          controls.enabled = true;
          isInDesktop = false;

          // Show UI again
          document.getElementById('controls-hint').classList.remove('hidden');
        }
      }

      animateZoomOut();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (!isZooming) {
        controls.update();
      }

      const time = Date.now() * 0.001;

      // Animate floating clouds
      clouds.forEach(cloud => {
        cloud.position.x += cloud.userData.speed;
        // Reset cloud when it goes too far
        if (cloud.position.x > 15) {
          cloud.position.x = -15;
        }
      });

      // Animate cats walking
      cats.forEach(cat => {
        cat.userData.walkTimer += 0.016;

        // Change direction occasionally
        if (Math.random() < 0.005) {
          cat.userData.direction += (Math.random() - 0.5) * Math.PI;
          cat.userData.isWalking = Math.random() > 0.3;
        }

        if (cat.userData.isWalking) {
          // Move cat
          cat.position.x += Math.cos(cat.userData.direction) * cat.userData.speed;
          cat.position.z += Math.sin(cat.userData.direction) * cat.userData.speed;

          // Face walking direction
          cat.rotation.y = -cat.userData.direction + Math.PI / 2;

          // Bobbing animation while walking
          cat.position.y = 0.1 + Math.sin(time * 10) * 0.015;

          // Keep cat in bounds
          if (Math.abs(cat.position.x) > 5) cat.userData.direction = Math.PI - cat.userData.direction;
          if (cat.position.z < 0.5 || cat.position.z > 5) cat.userData.direction = -cat.userData.direction;
        }
      });

      // Animate butterflies
      butterflies.forEach(bf => {
        const data = bf.userData;
        // Circular flying pattern
        bf.position.x += Math.sin(time * data.speed + data.phase) * 0.01;
        bf.position.z += Math.cos(time * data.speed + data.phase) * 0.01;
        bf.position.y = data.baseY + Math.sin(time * 2 + data.phase) * 0.15;

        // Face direction of movement
        bf.rotation.y = time * data.speed + data.phase;

        // Wing flapping
        if (bf.children[0]) {
          bf.children[0].rotation.y = Math.sin(time * 15 + data.wingPhase) * 0.5;
        }
        if (bf.children[1]) {
          bf.children[1].rotation.y = -Math.sin(time * 15 + data.wingPhase) * 0.5;
        }
      });

      // Animate coffee steam
      steamParticles.forEach(s => {
        s.position.y += 0.001 * s.userData.speed;
        s.material.opacity = 0.15 * (1 - (s.position.y - s.userData.baseY) / 0.15);
        if (s.position.y > s.userData.baseY + 0.15) {
          s.position.y = s.userData.baseY;
          s.position.x = 1.1 + (Math.random()-0.5)*0.03;
        }
      });

      // Animate floating Z's
      for (let i = 0; i < 3; i++) {
        const z = scene.getObjectByName('zzz_' + i);
        if (z) {
          z.position.y = z.userData.baseY + Math.sin(time * 0.8 + z.userData.phase) * 0.06;
          z.position.x = 0.15 + Math.sin(time * 0.5 + z.userData.phase) * 0.04;
          z.material.opacity = 0.3 + Math.sin(time + z.userData.phase) * 0.2;
        }
      }

      // Animate sleeping character breathing
      const sleeper = scene.getObjectByName('sleepingCharacter');
      if (sleeper) {
        sleeper.userData.breathPhase += 0.02;
        // Subtle torso rise/fall
        if (sleeper.children[0]) {
          sleeper.children[0].position.y = 0.72 + Math.sin(sleeper.userData.breathPhase) * 0.008;
        }
        // Head bobs very slightly
        if (sleeper.children[1]) {
          sleeper.children[1].position.y = 0.6 + Math.sin(sleeper.userData.breathPhase) * 0.005;
        }
      }

      // Subtle screen flicker
      if (screenLight) {
        screenLight.intensity = 0.5 + Math.sin(time * 3) * 0.02 + Math.random() * 0.01;
      }

      if (composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) composer.setSize(window.innerWidth, window.innerHeight);
      if (fxaaPass) {
        fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
      }
    }

    window.addEventListener('resize', onWindowResize);

    // ESC to exit desktop
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isInDesktop) {
        exitDesktop();
      }
    });

    // Listen for messages from iframe (e.g., shutdown -> power on)
    window.addEventListener('message', (e) => {
      if (e.data === 'exitDesktop' && isInDesktop) {
        exitDesktop();
      }
    });

    // Mobile redirect
    if (/Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768) {
      window.location.href = 'mobile.html';
    }

    // Initialize
    try { init(); } catch(e) { document.getElementById('controls-hint').innerHTML = '<div style="color:red;font-size:16px;">ERROR: ' + e.message + '<br>' + e.stack + '</div>'; console.error(e); }
  </script>
</body>
</html>
<!-- v2.3.0 - fixed screen glitch and clipping issues -->
